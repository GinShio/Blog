[{"categories":["编译原理"],"content":"GinShio | 编译原理第三章读书笔记","date":"2020-10-17","objectID":"/2020/compilerprinciple_003/","tags":["笔记","龙书"],"title":"编译原理 (3) – 词法分析2","uri":"/2020/compilerprinciple_003/"},{"categories":["编译原理"],"content":"基于DFA的模式匹配器的优化 ","date":"2020-10-17","objectID":"/2020/compilerprinciple_003/:1:0","tags":["笔记","龙书"],"title":"编译原理 (3) – 词法分析2","uri":"/2020/compilerprinciple_003/"},{"categories":["编译原理"],"content":"NFA的重要状态 如果一个 NFA 状态有一个标号非 \\(\\varepsilon\\) 的离开转换, 那么我们称这个状态为 重要状态 (important state)。子集构造法在计算 \\(\\varepsilon-closure(move(T, a))\\) 的时候, 它只使用了集合T中的重要状态, 也就是说只有当状态s是重要的, 状态集合 \\(move(s,a)\\) 才可能是非空的。在子集构造法的应用过程中, 两个NFA状态集合可以被认为是一致的条件是: 具有相同的重要状态, 且 要么都包含接受状态, 要么都不包含接受状态 如果 NFA 是使用 McMaughton-Yamada-Thompson 算法根据一个正则表达式生成的, 那么我们可以获得更多重要状态的性质: 重要状态只包括在基础规则部分为正则表达式中某个特定符号位置引入的初始状态, 即每个重要状态对应于正则表达式中的某个运算分量 NFA 只有一个接受状态, 但该接受状态不是重要状态。我们可以在正则表达式r的右端连接一个独特的结束标记符 #, 使得r的接收状态增加一个在#上的转换, 使其成为 (r)# 的NFA的重要状态 NFA 的重要状态直接对应于正则表达式中存放了字母表中符号的位置, 使用抽象语法树来表示扩展的正则表达式是非常有用的 ","date":"2020-10-17","objectID":"/2020/compilerprinciple_003/:1:1","tags":["笔记","龙书"],"title":"编译原理 (3) – 词法分析2","uri":"/2020/compilerprinciple_003/"},{"categories":["编译原理"],"content":"抽象语法树 抽象语法树的叶子结点对应于运算分量, 内部结点表示运算符。标号为 连接运算符 (\\(\\circ\\)) 的内部结点被称为 cat结点, 并运算符 (\\(|\\)) 的内部结点被称为 or结点, 星号运算符 (\\(*\\)) 的内部结点被称为 star结点, 我们构建正则表达式 \\((a|b)^{*}abb\\#\\) 的抽象语法树。 抽象语法树的叶子结点可以标号为 \\(\\varepsilon\\), 也可以用字母表中的符号作为标号, 对于每个标号不为 \\(\\varepsilon\\) 的叶子结点, 我们赋予一个独立的整数, 我们将这个整数称作叶子结点的 位置, 同时也表示和它对应的符号的位置, 当然一个符号可以有多个位置。抽象语法树中的这些位置对应构造出的 NFA 中的重要状态。 ","date":"2020-10-17","objectID":"/2020/compilerprinciple_003/:1:2","tags":["笔记","龙书"],"title":"编译原理 (3) – 词法分析2","uri":"/2020/compilerprinciple_003/"},{"categories":["编译原理"],"content":"计算函数 要从一个正则表达式直接构造出 DFA, 我们要先构造出它的抽象语法树, 然后计算如下四个函数: nullable 、 firstpos 、 lastpos 和 followpos, 且这四个函数都用到了扩展正则表达式 (r)# 的抽象语法树。 nullable(n): 当且仅当此结点代表的子表达式的语言中包含空串 \\(\\varepsilon\\) 时抽象语法树结点n为真, 即: 这个子表达式可以生成空串或本身就是空串, 即使它也可能表示其他串 firstpos(n): 定义了以结点n为根的子树中的位置集合, 这些位置对应于以n为根的子表达式的语言中某个串的 第一个符号 lastpos(n): 定义了以结点n为根的子树中的位置集合, 这些位置对应于以n为根的子表达式的语言中某个串的 最后一个符号 followpos(p): 定义了一个和位置p相关的、抽象语法树中的某些位置的集合。当且仅当存在 L((r)#) 中的某个串 \\(x=a_{1}a_{2}\\cdots a_{n}\\), 使得我们在解释为什么x属于 L((r)#) 时, 可以将x中的某个 \\(a_{i}\\) 和抽象语法树中的位置p匹配, 且将位置 \\(a_{i+1}\\) 和位置q匹配, 那么位置q在 \\(followpos(p)\\) 中。简单地说, 该函数计算出位置n之后可以跟随的其他位置 在计算函数时, 我们先给出较为简单的 nullable 、 firstpos 和 lastpos 的计算方式, 我可可以使用一个对树的高度直接进行递归的过程来计算它们。 结点n nullable(n) firstpos(n) lastpos(n) 一个标号为 \\(\\varepsilon\\) 的叶子结点 true \\(\\emptyset\\) \\(\\emptyset\\) 一个位置为 i 的叶子结点 false {i} {i} 一个 or 结点, \\(n = c_{1}\\mid c_{2}\\) \\(nullable(c_{1})\\) or \\(nullable(c_{2})\\) \\(firstpos(c_{1}) \\cup firstpos(c_{2})\\) \\(lastpos(c_{1}) \\cup lastpos(c_{2})\\) 一个 cat 结点, \\(n = c_{1}c_{2}\\) \\(nullable(c_{1})\\) and \\(nullable(c_{2})\\) if (\\(nullable(c_{1})\\)) \\(firstpos(c_{1}) \\cup firstpos(c_{2})\\) else \\(firstpos(c_{1})\\) if (\\(nullable(c_{2})\\)) \\(lastpos(c_{1}) \\cup lastpos(c_{2})\\) else \\(lastpos(c_{2})\\) 一个 star 结点, \\(n=(c_{1})^{*}\\) true \\(firstpos(c_{1})\\) \\(lastpos(c_{1})\\) followpos 的概念有些复杂, 我们先来了解如何计算 followpos, 只有两种情况会使得正则表达式的某个位置跟在另一个位置之后: 如果 n 是 cat 结点, 且其左右子结点分别是 \\(c_{1}\\) 和 \\(c_{2}\\), 那么对于 \\(lastpos(c_{1})\\) 中的每个位置 i, \\(firstpos(c_{2})\\) 中的所有位置都在 \\(followpos(i)\\) 中 如果 n 是 star 结点, 且 i 是 \\(lastpos(n)\\) 中的一个位置, 那么 \\(firstpos(n)\\) 中的所有位置都在 \\(followpos(i)\\) 中 四个函数如何计算都已经给出, 现在我们用正则表达式 \\((a|b)^{*}abb\\#\\) 练练手, 下图给出构建出的语法分析树, 结点左边给出其 firstpos, 结点右边给出其 lastpos followpos 的计算规则1要求我们查看每个cat结点, 并将它的右子结点的firstpos中的每个位置放到它的左子结点的lastpos中各个位置的followpos中；计算规则2要求我们查看每个 star 结点, 并将它的firstpos中的所有位置放到它的lastpos中各个位置的followpos中。例如上图中最下面的一个 cat 结点, 根据规则1, 将位置3加入到 followpos(1) 和 followpos(2) 中。 位置n followpos(n) 1 {1,2,3} 2 {1,2,3} 3 {4} 4 {5} 5 {6} 6 \\(\\emptyset\\) 我们可以创建有向图来表示函数 followpos, 其中每个位置有一个对应的结点, 当且仅当j在followpos(i)中时从位置i到位置j有一条有向边。那么这个表示followpos函数的有向图几乎就是相应正则表达式的不含 \\(\\varepsilon\\) 转换的NFA，我们经过以下处理即可由有向图得到NFA 将根结点的firstpos中的所有位置设置为开始状态 在每条从i到j的有向边上添加位置i上的符号作为标号 把和结尾 # 相关的位置当作唯一的接收状态 ","date":"2020-10-17","objectID":"/2020/compilerprinciple_003/:1:3","tags":["笔记","龙书"],"title":"编译原理 (3) – 词法分析2","uri":"/2020/compilerprinciple_003/"},{"categories":["编译原理"],"content":"从正则表达式构造DFA 接下来我们给出算法, 直接从正则表达式构造DFA 技巧 输入：一个正则表达式 r 输出：一个识别 L(r) 的 DFA D 方法： 根据扩展的正则表达式 (r)# 构造出一颗抽象语法树 T 计算T的函数 nullable, firstpos, lastpos 和 followpos 构造出 D 的 状态集 \\(D_{states}\\) 和 D 的 转换函数 \\(D_{tran}\\), D的状态就是T中的位置集合, 开始状态是 \\(firstpos(n_{0})\\) (\\(n_{0}\\) 是T的根节点), 接受状态集合是那些包含了和结束标记#对应的位置的状态。每个状态最初都是 未标记的, 当我们开始考虑某个状态的离开转换时, 该状态就变为 已标记的 构造的伪代码如下: while Dstates 中存在未标记的状态S: 标记 S for 每个输入符号a: 令 U 为 S 中和 a 对应的所有位置p的 followpos(p) 的并集 if U 不在 Dstates 中: 将 U 作为未标记的状态加入 Dstates 中 Dtran[S, a] = U 依然以 \\((a|b)^{*}abb\\) 为例构造 DFA, 正则表达式所构造出的语法分析树上面已有, 分析语法分析树可知只有 star 结点的 nullable 为真。 这颗树的根结点的 firstpos 集为 {1,2,3}, 即 DFA 的开始状态集合, 我们称这个集合为 A。计算 \\(D_{tran}[A, a]\\) 和 \\(D_{tran}[A, b]\\), A中1和3对应于a, 2对应于b, 所有 \\(D_{tran}[A, a] = followpos(1) \\cup followpos(3) = {1, 2, 3, 4}\\), \\(D_{tran}[A, b] = followpos(2) = {1,2,3}\\), 以此类推, 构造出该正则表达式的 DFA。 名称 集合 a b A {1,2,3} B A B {1,2,3,4} B C C {1,2,3,5} B D D {1,2,3,6} B A ","date":"2020-10-17","objectID":"/2020/compilerprinciple_003/:1:4","tags":["笔记","龙书"],"title":"编译原理 (3) – 词法分析2","uri":"/2020/compilerprinciple_003/"},{"categories":["编译原理"],"content":"最小化DFA 对于同一个语言, 可以存在多个识别此语言的DFA。对于不同的DFA, 各个状态的的名字可能不同, 状态的个数也可能不一样, 如果我们使用DFA实现词法分析器, 则希望DFA的状态数尽可能的少, 因为词法分析器的转换表需要为每个状态分配条目。 状态名如果不同, 但只改变状态名就可以将一个自动机转换为另一个自动机, 那么这两个自动机是 同构的, 反之则不是。有一个重要结论: 任何正则语言都有一个 唯一的 且 状态数目最少 的DFA, 而且从任意接受相同正则语言的DFA出发, 通过分组合并等价状态, 我们总可以构造出状态数最少的DFA。 我们以正则表达式 \\((a|b)^{*}abb\\) 的两个已经构造出的DFA来讲解最小化, 其中最小化的DFA是本篇中由正则表达式直接构造出的DFA, 另一个非同构DFA是上一篇中由NFA转换来的DFA。 在最小化DFA之前, 先说明输入串是如何区分各个状态的, 如果分别从状态s和t出发, 沿着标号为x的路径到达的两个状态只有一个是接受状态, 则串x 区分状态 s 和 t; 如果状态 s 和 t 存在能够区分它们的串, 那么它们就是 可区分的 。空串 \\(\\varepsilon\\) 可以区分如何一个接受状态和非接受状态。串 bb 区分状态 A 和 B, 因为从 A 出发经过标号 bb 的路径会到达非接受状态 C, 而从B出发可以到达接受状态。 DFA状态最小化的工作原理是将一个DFA的状态集合划分为多个组, 每个组中的各个状态相互不可区分, 但不同组的状态是可区分的, 每个组中的状态合并为最小DFA的一个状态, 当任意一个组都不能再被分解为更小的组时这个划分结束, 此时我们就得到了状态最少的DFA。具体方法如下: 首先构造包含两个组 F 和 S-F 的初始划分 \\(\\Pi\\), 这两个组分别是D的接受状态组和非接受状态组 应用以下方法构造新的分划 \\(\\Pi_{new}\\) Pi_new = Pi for Pi 中的每个组 G: 将 G 划分为更小的组, 当且仅当对于所有的输入符号a, 使得两个状态s和t在同一小组中, 状态s和t在a上的转换都到达 Pi 中的同一组 在 Pi_new 中将 G 替换为对 G 进行划分得到的那些小组 如果 \\(\\Pi_{new} = \\Pi\\), 令 \\(\\Pi_{final} = \\Pi\\) 并执行步骤4, 否则用 \\(\\Pi_{new}\\) 替换 \\(\\Pi\\) 并重复步骤2 在划分 \\(\\Pi_{final}\\) 的每个组中选取一个状态作为该组的代表, 这些代表构成了状态最少 DFA 的状态。最小状态DFA \\(D’\\) 的其他部分按如下步骤构造: \\(D’\\) 的开始状态是包含了 D 的开始状态的组的代表 \\(D’\\) 的接受状态是那些包含了 D 的接受状态的组的代表。每个组要么只包含了接受状态, 要么只包含了非接受状态, 因为我们一开始将这两类状态分开了 令 s 是 \\(\\Pi_{final}\\) 中某个组 G 的代表, 并令 DFA 中正在输入 a 上离开 s 的转换到达状态 t, 令 r 为 t 所在组 H 的代表, 那么在 \\(D’\\) 中存在一个从 s 到 r 在输入 a 上的转换 上述算法可能会产生一个带有 死状态 的DFA, 所谓死状态是在所有输入符号上都转向自己的非接受状态。我们可以消除掉死状态, 使这个DFA可能会变为缺少某些转换的自动机。 ","date":"2020-10-17","objectID":"/2020/compilerprinciple_003/:1:5","tags":["笔记","龙书"],"title":"编译原理 (3) – 词法分析2","uri":"/2020/compilerprinciple_003/"},{"categories":["Apps"],"content":"在服务器上搭建一些自己用的到的服务","date":"2020-10-13","objectID":"/2020/service/","tags":["server","Application"],"title":"在服务器上部署一些服务","uri":"/2020/service/"},{"categories":["Apps"],"content":"个人使用的是腾讯云的轻量服务器, 系统镜像选择的是 Ubuntu 20.04, 搭建的服务有 博客 HUGO 、私有网盘 Nextcloud 以及 Git服务器 GitLab 一下服务搭建时, 域名统一使用 example.com, 请根据自己的情况修改对应的配置, 用到一些基础依赖请自行安装 Nginx Git PHP PostgreSQL Redis ","date":"2020-10-13","objectID":"/2020/service/:0:0","tags":["server","Application"],"title":"在服务器上部署一些服务","uri":"/2020/service/"},{"categories":["Apps"],"content":"Nextcloud Nextcloud 是 ownCloud 项目的一个分支, 一个开源的私有云盘应用, 官方提供了包括 桌面以及移动系统的客户端。 ","date":"2020-10-13","objectID":"/2020/service/:1:0","tags":["server","Application"],"title":"在服务器上部署一些服务","uri":"/2020/service/"},{"categories":["Apps"],"content":"Nextcloud 依赖 Nextcloud 依赖 PHP 运行时以及数据库 (MySQL 5.7+ / MariaDB 10.2+ 或 PostgreSQL) apt install -y nginx postgresql \\ php php-fpm php-cli php-mysql php-pgsql php-sqlite3 php-redis \\ php-apcu php-memcached php-bcmath php-intl php-mbstring php-json php-xml \\ php-curl php-imagick php-gd php-zip php-gmp php-ctype php-dom php-iconv php-zlib PHP: 修改 php-fpm 的配置文件 fpm_path=\"/etc/php/7.4/fpm\" cd $fpm_path # php config sed -i \"s/memory_limit = .*/memory_limit = 512M/\" php.ini sed -i \"s/;date.timezone.*/date.timezone = UTC/\" php.ini sed -i \"s/;cgi.fix_pathinfo=1/cgi.fix_pathinfo=1/\" php.ini sed -i \"s/upload_max_filesize = .*/upload_max_filesize = 4096M/\" php.ini sed -i \"s/post_max_size = .*/post_max_size = 4096M/\" php.ini sed -i \"s/max_input_time = .*/max_input_time = 480/\" php.ini sed -i \"s/max_execution_time = .*/max_execution_time = 360/\" php.ini sed -i \"s/pm.max_children = .*/pm.max_children = 32/\" pool.d/www.conf sed -i \"s/pm.min_spare_servers = .*/pm.min_spare_servers = 1/\" pool.d/www.conf sed -i \"s/pm.max_spare_servers = .*/pm.max_spare_servers = 8/\" pool.d/www.conf sed -i \"s/pm.start_servers = .*/pm.start_servers = 4/\" pool.d/www.conf sed -i \"s/;clear_env = no/clear_env = no/\" pool.d/www.conf # opcache config sed -i \"s/;opcache.enable=1/opcache.enable=1/\" php.ini sed -i \"s/;opcache.memory_consumption=128/opcache.memory_consumption=128/\" php.ini sed -i \"s/;opcache.interned_strings_buffer=8/opcache.interned_strings_buffer=8/\" php.ini sed -i \"s/;opcache.max_accelerated_files=10000/opcache.max_accelerated_files=10000/\" php.ini sed -i \"s/;opcache.revalidate_freq=2/opcache.revalidate_freq=1/\" php.ini # apc config echo \"[apc]\" \u003e\u003e php.ini echo \"apc.cache_by_default = on\" \u003e\u003e php.ini echo \"apc.enable_cli = off\" \u003e\u003e php.ini echo \"apc.enable = on\" \u003e\u003e php.ini echo \"apc.file_update_protection = 2\" \u003e\u003e php.ini # restart systemctl restart php7.4-fpm PostgreSQL: 创建用户 nextcloud 和数据库 nextcloud_db adduser --disabled-login --gecos 'Nextcloud' nextcloud sudo -u postgres -H psql -c \"CREATE USER nextcloud WITH PASSWORD 'YourPassword'\" sudo -u postgres -H psql -c \"CREATE DATABASE nextcloud_db OWNER nextcloud\" Nginx: 配置网站, 修改 官方示例配置文件 并保存在 /etc/nginx/sites-available/nextcloud ln -sf /etc/nginx/sites-available/nextcloud /etc/nginx/sites-enabled/ nginx -t # 检查配置文件 systemctl restart nginx ","date":"2020-10-13","objectID":"/2020/service/:1:1","tags":["server","Application"],"title":"在服务器上部署一些服务","uri":"/2020/service/"},{"categories":["Apps"],"content":"Nextcloud 安装 下载 你需要的版本并解压到目录中, 这里假设解压后的目录为 /var/www/nextcloud sudo chown -R www-data:www-data /var/www/nextcloud/ sudo -u www-data -H mkdir -p /var/www/nextcloud/data 准备工作完成后, 进入网页, 设置管理员帐号和数据库 ","date":"2020-10-13","objectID":"/2020/service/:1:2","tags":["server","Application"],"title":"在服务器上部署一些服务","uri":"/2020/service/"},{"categories":["Apps"],"content":"GitLab GitLab 是开源的基于git的 web DevOps生命周期工具, 提供了 Git仓库 、 问题追踪 和 CI/CD 等功能。分为社区版和企业版, 使用相同内核, 部分功能社区版没有提供。Gitlab 相较消耗资源, 官方推荐的最低要求为 4C4G 可以最多支持500用户, 8C8G 最多支持1000用户, 具体的使用受到 用户的活跃程度 、 CI/CD 、 修改大小 等因素影响。 由于暂时不需要, 没有安装 Gitlab Pages, Gitlab的安装依赖 git 用户, 以下是目录结构 |-- home | |-- git | |-- .ssh | |-- gitaly | |-- gitlab | |-- gitlab-shell | |-- gitlab-workhorse | |-- repositories ","date":"2020-10-13","objectID":"/2020/service/:2:0","tags":["server","Application"],"title":"在服务器上部署一些服务","uri":"/2020/service/"},{"categories":["Apps"],"content":"Gitlab 组件 Gitaly: 处理所有的 git 操作 GitLab Shell: 处理基于 SSH 的 git 会话 与 SSH密钥 GitLab Workhorse: 反向代理服务器, 处理与Rails无关的请求, Git Pull/Push 请求 和 到Rails的连接, 减轻Web服务的压力, 帮助整体加快Gitlab的速度 Unicorn / Puma: Gitlab 自身的 Web 服务器, 提供面向用户的功能, Gitlab 13.0 起默认使用 Puma Sidekiq: 后台任务服务器, 从Redis队列中提取任务并进行处理 GitLab Pages: 允许直接从仓库发布静态网站 Gitlab Runner: Gitlab CI/CD 所关联的任务处理器 Nginx: Web服务器 PostgreSQL: 数据库 ","date":"2020-10-13","objectID":"/2020/service/:2:1","tags":["server","Application"],"title":"在服务器上部署一些服务","uri":"/2020/service/"},{"categories":["Apps"],"content":"Gitlab 依赖 目前Gitlab最新版本为 v13.x, 我们安装最新版本 Ruby v2.6 or later GoLang v1.13 or later Git v2.24 (推荐 v2.28) or later Node.js v10.13.0 (推荐 v12) or later yarn v1.10.0 or later Nginx Redis v4.0 (推荐v5.0) or later PostgreSQL v11 or later 安装相关依赖, 建立数据库, 将 Redis 设置为 Unix Domain Socket (UDS) 连接 apt update -y \u0026\u0026 apt upgrade -y # 安装依赖 sudo apt install -y build-essential zlib1g-dev libyaml-dev libssl-dev libgdbm-dev libre2-dev \\ libreadline-dev libncurses5-dev libffi-dev curl openssh-server checkinstall libxml2-dev \\ libxslt-dev libcurl4-openssl-dev libicu-dev logrotate rsync python-docutils pkg-config \\ cmake vim runit postfix libimage-exiftool-perl golang nodejs # Ruby sudo gem install bundler --no-document --version '\u003c 2' # Node.js curl --silent --show-error https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add - echo \"deb https://dl.yarnpkg.com/debian/ stable main\" | sudo tee /etc/apt/sources.list.d/yarn.list sudo apt-get update sudo apt-get install yarn # 数据库 sudo adduser --disabled-login --gecos 'GitLab' git sudo apt install postgresql postgresql-client libpq-dev postgresql-contrib sudo systemctl start postgresql sudo -u postgres psql -d template1 -c \"CREATE USER git WITH PASSWORD 'YourPassword' CREATEDB;\" sudo -u postgres psql -d template1 -c \"CREATE EXTENSION IF NOT EXISTS pg_trgm;\" sudo -u postgres psql -d template1 -c \"CREATE EXTENSION IF NOT EXISTS btree_gist\"; sudo -u postgres psql -d template1 -c \"CREATE DATABASE gitlabhq_production OWNER git;\" # Redis sudo apt install redis-server sudo cp /etc/redis/redis.conf /etc/redis/redis.conf.orig sudo sed 's/^port .*/port 0/' /etc/redis/redis.conf.orig | sudo tee /etc/redis/redis.conf echo 'unixsocket /var/run/redis/redis.sock' | sudo tee -a /etc/redis/redis.conf echo 'unixsocketperm 770' | sudo tee -a /etc/redis/redis.conf sudo mkdir -p /var/run/redis sudo chown redis:redis /var/run/redis sudo chmod 755 /var/run/redis if [ -d /etc/tmpfiles.d ]; then echo 'd /var/run/redis 0755 redis redis 10d -' | sudo tee -a /etc/tmpfiles.d/redis.conf fi sudo systemctl restart redis sudo usermod -aG redis git ","date":"2020-10-13","objectID":"/2020/service/:2:2","tags":["server","Application"],"title":"在服务器上部署一些服务","uri":"/2020/service/"},{"categories":["Apps"],"content":"Gitlab 安装 以下配置完成后, Gitlab基本配置完成, 登录网站设置默认管理员密码即可登录, 默认管理员帐号为 root gitlab_path=/home/git/gitlab gitaly_path=/home/git/gitaly # install gitlab cd /home/git sudo -u git -H git clone https://gitlab.com/gitlab-org/gitlab-foss.git -b 13-0-stable gitlab cd ${gitlab_path} sudo -u git -H cp config/gitlab.yml.example config/gitlab.yml sudo -u git -H editor config/gitlab.yml sudo -u git -H cp config/secrets.yml.example config/secrets.yml sudo -u git -H chmod 0600 config/secrets.yml sudo chown -R git log/ sudo chown -R git tmp/ sudo chmod -R u+rwX,go-w log/ sudo chmod -R u+rwX tmp/ sudo chmod -R u+rwX tmp/pids/ sudo chmod -R u+rwX tmp/sockets/ sudo -u git -H mkdir -p public/uploads/ sudo chmod 0700 public/uploads sudo chmod -R u+rwX builds/ sudo chmod -R u+rwX shared/artifacts/ sudo chmod -R ug+rwX shared/pages/ sudo -u git -H cp config/puma.rb.example config/puma.rb sudo -u git -H editor config/puma.rb sudo -u git -H git config --global core.autocrlf input sudo -u git -H git config --global gc.auto 0 sudo -u git -H git config --global repack.writeBitmaps true sudo -u git -H git config --global receive.advertisePushOptions true sudo -u git -H git config --global core.fsyncObjectFiles true sudo -u git -H cp config/resque.yml.example config/resque.yml sudo -u git -H editor config/resque.yml sudo -u git cp config/database.yml.postgresql config/database.yml sudo -u git -H editor config/database.yml sudo -u git -H chmod o-rwx config/database.yml # install gems sudo -u git -H bundle install --deployment --without development test mysql aws kerberos # install gitlab-shell sudo -u git -H bundle exec rake gitlab🐚install RAILS_ENV=production sudo -u git -H editor /home/git/gitlab-shell/config.yml # install gitlab-workhorse sudo -u git -H bundle exec rake \"gitlab:workhorse:install[/home/git/gitlab-workhorse]\" RAILS_ENV=production # install gitaly cd ${gitlab_path} sudo -u git -H bundle exec rake \"gitlab:gitaly:install[/home/git/gitaly,/home/git/repositories]\" RAILS_ENV=production sudo chmod 0700 ${gitlab_path}/tmp/sockets/private sudo chown git ${gitlab_path}/tmp/sockets/private sudo -u git -H editor ${gitaly_path}/config.toml sudo -u git -H sh -c \"$gitlab_path/bin/daemon_with_pidfile $gitlab_path/tmp/pids/gitaly.pid \\ $gitaly_path/gitaly $gitaly_path/config.toml \u003e\u003e $gitlab_path/log/gitaly.log 2\u003e\u00261 \u0026\" # 初始化 sudo -u git -H bundle exec rake gitlab:setup RAILS_ENV=production force=yes sudo cp lib/support/init.d/gitlab /etc/init.d/gitlab sudo cp lib/support/init.d/gitlab.default.example /etc/default/gitlab sudo update-rc.d gitlab defaults 21 sudo systemctl enable gitlab sudo cp lib/support/logrotate/gitlab /etc/logrotate.d/gitlab sudo -u git -H bundle exec rake gitlab:env:info RAILS_ENV=production # GetText PO files sudo -u git -H bundle exec rake gettext:compile RAILS_ENV=production # Assets sudo -u git -H yarn install --production --pure-lockfile sudo -u git -H bundle exec rake gitlab:assets:compile \\ RAILS_ENV=production NODE_ENV=production \\ NODE_OPTIONS=\"--max_old_space_size=1024\" # 内存限制在1G if [ $? != 0 ]; then echo \"compile assets error. desc '--max_old_space_size'\" return 64 fi # Nginx sudo cp lib/support/nginx/gitlab-ssl /etc/nginx/sites-available/gitlab sudo ln -sf /etc/nginx/sites-available/gitlab /etc/nginx/sites-enabled/gitlab sudo editor /etc/nginx/sites-available/gitlab sudo nginx -t; if [ $? != 0 ]; then echo \"nginx config error. editor /etc/nginx/sites-available/gitlab\" return 64 fi # end sudo -u git -H bundle exec rake gitlab:check RAILS_ENV=production sudo systemctl start gitlab 接下来安装 Gitlab Runner v13.4.1, 使 CI/CD 可用 curl -LJO https://gitlab-runner-downloads.s3.amazonaws.com/latest/deb/gitlab-runner_amd64.deb dpkg -i gitlab-runner_amd64.deb sudo gitlab-runner register # 注册 runner sudo -u gitlan-runner -H mv /home/gitlab-runner/.bash_logout /home/gitlab-runner/.bash_logout.bkp sudo systemctl restart gitlab-runnner sudo systemctl enable gitlab-runner ","date":"2020-10-13","objectID":"/2020/service/:2:3","tags":["server","Application"],"title":"在服务器上部署一些服务","uri":"/2020/service/"},{"categories":["编译原理"],"content":"GinShio | 编译原理第三章读书笔记","date":"2020-07-16","objectID":"/2020/compilerprinciple_002/","tags":["笔记","龙书"],"title":"编译原理 (2) – 词法分析1","uri":"/2020/compilerprinciple_002/"},{"categories":["编译原理"],"content":"词法分析是编译器的第一阶段, 主要负责读取源程序的输入字符, 将它们组成 词素, 生成并输出一个词法单元序列, 每个词法单元对应一个词素, 这个词法单元序列将被语法分析器进行语法分析。除此之外, 词法分析器还会过滤源程序中的注释和空白, 生成错误信息与源程序的位置关联起来, 有时还会进行宏扩展。 学习词法分析时, 需要分清以下三个相关但有区别的术语 词法单元, 由一个词法单元名和一个可选的属性值组成, 词法单元名是一个表示某种词法单位的抽象符号, 比如关键字, 或标识符的输入字符序列 词素, 源程序中的字符序列, 它和某一词法单元的模式匹配, 并被词法分析器识别为该词法单元的一个实例 模式, 描述了一个词法单元的词素可能具有的形式。对于关键词它是组成关键字的字符序列; 对于标识符和其他词法单元, 模式是一个更加复杂的结构, 可以和很多符号串匹配 比如 printf(\"Total=%d\\n\", source); 中, printf 和 source 都是和词法单元 id 的模式匹配的词素, 而字符串则是一个和 literal 匹配的词素, 以下表格为词法单元的示例 词法单元 非正式描述 词素示例 if 关键字, 字符 i/f if else 关键字, 字符 e/l/s/e else comparison 比较运算符 \u003c, \u003c= id 普通标识符 pi, D2, source number 数字常量 3.1415926, 1024 literal 字符串常量 “hello world!” ","date":"2020-07-16","objectID":"/2020/compilerprinciple_002/:0:0","tags":["笔记","龙书"],"title":"编译原理 (2) – 词法分析1","uri":"/2020/compilerprinciple_002/"},{"categories":["编译原理"],"content":"词法单元的规约 ","date":"2020-07-16","objectID":"/2020/compilerprinciple_002/:1:0","tags":["笔记","龙书"],"title":"编译原理 (2) – 词法分析1","uri":"/2020/compilerprinciple_002/"},{"categories":["编译原理"],"content":"串和语言 字母表 (alphabet) 是一个有限的符号集合, 符号的典型示例是包括字母、数字和标点符号, 常见的字母表如 ASCII 和 Unicode 。 串 (string) 是某个字母表中符号的一个有穷序列, 串 s 的长度, 表示 s 中符号出现的次数, 记作 \\(|s|\\), 长度为 0 的串被称为空串, 记作 \\(\\varepsilon\\) 。 语言 (language) 是某个给定字母表上一个任意的可数的串的集合, 此外空集 \\(\\varnothing\\) 和 仅包含空串的集合都是语言。 词法分析中, 最重要的语言上的运算是 并 、 连接 和 闭包 。连接是将一个串附加到另一个串的后面形成新串, 例如 \\(x=dog, y=house\\), 那么 x、y 的连接 \\(xy=doghouse\\); 空串是连接运算的 单位元, 即对于任意串 \\(s\\varepsilon = \\varepsilon s = s\\) 。两个串的连接可以被看作乘积, 那么可以定义串的指数运算: \\(s^0=\\varepsilon, s^i = s^{i-1}s(i \u003e 0)\\) 。Kleene 闭包 (closure), 记作 \\(L^{*}\\), 即将 L 连接 0 次或多次后得到的串集; 正闭包 与闭包基本相同, 但不包括 \\(L^0\\), 也就是说, 除非 \\(\\varepsilon\\) 属于 L, 否则 \\(\\varepsilon \\notin L\\) 。 运算 定义和表示 L 和 M 的并 \\(L \\cup M = \\{s \\mid s \\in L \\ or\\ s \\in M\\}\\) L 和 M 的连接 \\(LM = \\{st \\mid s \\in L \\ and\\ t \\in M\\}\\) L 的 Kleene 闭包 \\(L^{*} = \\cup_{i=0}^{\\infty} L^i\\) L 的正闭包 \\(L^{+} = \\cup_{i=1}^{\\infty} L^i\\) 示例 令 L = {A, B, \\(\\ldots\\), Z, a, b, \\(\\ldots\\), z}, 令 D = {0, 1, \\(\\ldots\\), 9}, 这是两个字母表, 也可以认为是两个串长都为 1 的语言, 对他们进行上述 4 种运算 \\(L \\cup D\\) 是字母和数字的集合, 结果是 62 个长度为 1 的串 \\(LD\\) 是包含 520 个长度为 2 的集合, 每个串都是一个字母跟一个数字 \\(L^4\\) 是由四个字母构成的串的集合 \\(L^{*}\\) 是由字母构成的串的集合, 包含空串 \\(\\varepsilon\\) \\(D^{+}\\) 是由一个或多个数字构成的串的集合, 不包含空串 ","date":"2020-07-16","objectID":"/2020/compilerprinciple_002/:1:1","tags":["笔记","龙书"],"title":"编译原理 (2) – 词法分析1","uri":"/2020/compilerprinciple_002/"},{"categories":["编译原理"],"content":"正则表达式 正则表达式由常量和运算构成, 它们分别是字符串的集合和在这些集合上的运算, 正则表达式可以由较小的正则表达式按照一定规则递归地构建。 归纳基础 \\(\\varepsilon\\) 是一个正则表达式, \\(L(\\varepsilon) = \\{\\varepsilon\\}\\), 即该语言仅包含空串 如果 a 是 \\(\\Sigma\\) 上的一个符号, 那么 a 是一个正则表达式, 并且 \\(L(\\textbf{a}) = \\{a\\}\\), 即该语言仅包含一个长度为 1 的字符串 a 归纳步骤: 假定 r 和 s 都是正则表达式, 分别表示语言 \\(L( r)\\) 和 \\(L(s)\\), 那么: \\(( r)|(s)\\) 是一个正则表达式, 表示语言 \\(L( r) \\cup L(s)\\) \\(( r)(s)\\) 是一个正则表达式, 表示语言 \\(L( r)L(s)\\) \\(( r)^{*}\\) 是一个正则表达式, 表示语言 \\((L( r))^{*}\\) \\(( r)\\) 是一个正则表达式, 表示语言 \\(L( r)\\) 按照以上定义, 正则表达式经常会包含一些不必要的括号, 一般正则表达式有如下优先级 一元运算符 \\(*\\) 具有最高优先级, 是左结合的 连接具有次高优先级, 是左结合的 \\(|\\) 优先级最低, 是左结合的 以下表格列出正则表达式中常用定律 定律 描述 \\(r\\mid s = s\\mid r\\) \\(\\mid\\) 满足交换律 \\(r\\mid(s \\mid t) = (r \\mid s) \\mid t\\) \\(\\mid\\) 满足结合律 \\(r(st) = (rs)t\\) 连接满足结合律 \\(r(s \\mid t) = rs \\mid rt; (s \\mid t)r = sr \\mid tr\\) 连接对 \\(\\mid\\) 满足分配率 \\(\\varepsilon r = r\\varepsilon = r\\) \\(\\varepsilon\\) 是连接的单位元 \\(r^{*} = (r\\mid\\varepsilon)^{*}\\) Kleene 闭包中一定包含 ε \\(r^{**} = r^{*}\\) \\(*\\) 具有幂等性 ","date":"2020-07-16","objectID":"/2020/compilerprinciple_002/:1:2","tags":["笔记","龙书"],"title":"编译原理 (2) – 词法分析1","uri":"/2020/compilerprinciple_002/"},{"categories":["编译原理"],"content":"正则定义 如果 \\(\\Sigma\\) 是 基本符号集, 那么一个 正则定义 (regular definition) 是具有如下形式的定义序列 \\[ \\begin{aligned} d_1 \\rightarrow r_1 \\\\ d_2 \\rightarrow r_2 \\end{aligned} \\\\ \\dots \\\\ d_n \\rightarrow r_n \\] 每个 \\(d_i\\) 都是一个新符号, 它们都不在 \\(\\Sigma\\) 中, 并且各不相同 每个 \\(r_i\\) 是字母表 \\(\\Sigma \\cup \\{d_1, d_2, \\ldots, d_n\\}\\) 上的正则表达式 示例 C 语言的标识符是由字母或下划线开头, 字母、数字和下划线组成的串, 正则定义如下 \\[ \\begin{aligned} \\textit{letter}\\_ \u0026 \\rightarrow A | B | \\ldots | Z | a | b | \\ldots | z | \\_ \\\\ \\textit{digit} \u0026 \\rightarrow 0 | 1 | \\ldots | 9 \\\\ \\textit{id} \u0026 \\rightarrow \\textit{letter\\_}(\\textit{letter\\_}|dight)^{*} \\end{aligned} \\] 在进行词法分析器的规约时, 现有的正则定义太过于麻烦, 于是对其做了一些扩展, 当然除了以下介绍的 GNU 、 Perl 等都有互不兼容的正则表达式扩展 一个或多个实例 (+), 表示一个正则表达式及其语言的正闭包, + 与 * 具有相同的优先级与结合性 零个或一个实例 (?), 表示一个正则表达式及其语言出现零或一次, \\(r? = r|\\varepsilon\\), ? 与 * 具有相同的优先级与结合性 字符类, 一个正则表达式 \\(a_1 | a_2 | \\ldots | a_n\\) 可以缩写为 \\([a_1a_2\\ldots a_n]\\), 如果 \\(a_1\\) 到 \\(a_n\\) 是连接的序列时可以缩写为 \\([a_1-a_n]\\) 示例 C 语言的数字字面量可以分为 整型字面量 与 浮点型字面量, 以下给出它们的正则定义 \\[ \\begin{aligned} \\textit{digit}\u0026\\rightarrow [0-9] \\\\ \\textit{digits}\u0026\\rightarrow digit^{+} \\\\ \\textit{number}\u0026\\rightarrow [+-](\\textit{digits}.?\\textit{digit}^{*}|.\\textit{digits})([eE][+-]?\\textit{digits})? \\end{aligned} \\] ","date":"2020-07-16","objectID":"/2020/compilerprinciple_002/:1:3","tags":["笔记","龙书"],"title":"编译原理 (2) – 词法分析1","uri":"/2020/compilerprinciple_002/"},{"categories":["编译原理"],"content":"状态转换图 将模式首先需要转换为具有特定风格的流图, 我们称为 状态转化图 (transition diagram), 它有一组被称为 状态 (state) 的结点, 词法分析器扫描输入串的过程中寻找和某个模式匹配的词素, 状态图上的每个状态代表一个可能在过程中出现的情况, 结点包含了我们在进行词法分析时需要的全部信息。状态图的 边 (edge) 从图的一个状态指向另一个状态, 每条边的标号包含了一个或多个符号。例如我们现在处于状态 s 下, 下一个输入的符号为 a, 那么我们就会在状态图中寻找一条从 s 离开且符号为 a 的边, 并进入这条边所指向的下一个状态。关于状态转移图的重要约定如下 某些状态被称为 接受状态 或 最终状态, 在图中用双层圈表示, 如果该状态要执行一个动作, 通常是向语法分析器返回一个词法单元和相关属性值 如果要回退一个位置, 我们一般在该状态上加一个 *, 如果要回退多个位置则需要加相应数量的 * 一个状态被称为 开始状态 或 初始状态, 该状态由一条没有出发结点的、标号为 start 的边指明, 在读入任何符号之前, 状态图总是位于它的起始状态 我们用 SQL 中的关系运算符来举个例子 词素 词法单元名 属性值 \u003c relop LT \u003c= relop LE = relop EQ \u003c\u003e relop NE \u003e relop GT \u003e= relop GE 对于符号来说很简单, 但对于关键字来说, 它们是被保留的, 但它们看起来很像标识符, 因此我们常常使用两种方法来处理长的很像标识符的关键字 初始化时将各个保留字填入符号表, 符号表中的某个字段会指明这些串并非普通的标识符, 并指出它们所代表的词法单元 为每个保留字建立单独的状态转换图, 并设立词法单元的优先级, 当同时匹配关键字模式与 id 模式时优先识别保留字的词法单元 ","date":"2020-07-16","objectID":"/2020/compilerprinciple_002/:2:0","tags":["笔记","龙书"],"title":"编译原理 (2) – 词法分析1","uri":"/2020/compilerprinciple_002/"},{"categories":["编译原理"],"content":"有穷自动机 一些词法分析其生成程序使用了 有穷自动机 (finite automata) 这种表示方式, 其在本质上是与状态转换图类似的图, 但有如下不同 有穷自动机不是识别器, 它们只能对每个可能输入的串进行简单的回答是或否 分为两类 不确定有穷自动机 (Nondeterministic Finite Automata, NFA), 它们对其边上的标号没有任何限制, 一个符号标记离开同一状态的多条边, 并且空串也可以作为标记 确定有穷自动机 (Deterministic Finite Automata, DFA), 对于每个状态及自动机输入字母表的每个符号, 有且只有一条离开的状态、以该符号为标点的边 确定与不确定的有穷自动机能识别的语言的集合是相同的, 这些语言集合正好是能够用正则表达式描述的语言的集合, 这个集合中的语言被称为 正则语言 (regular language)。 ","date":"2020-07-16","objectID":"/2020/compilerprinciple_002/:3:0","tags":["笔记","龙书"],"title":"编译原理 (2) – 词法分析1","uri":"/2020/compilerprinciple_002/"},{"categories":["编译原理"],"content":"不确定的有穷状态机 首先, 一个 NFA 由以下几部分组成 一个有穷的状态集合 \\(S\\) 一个输入符号集 \\(\\Sigma\\), 即输入字母表, 我们假设 \\(\\varepsilon \\notin \\Sigma\\) 一个 转换函数 (transition function), 它为每个状态和 \\(\\Sigma \\cup \\{\\varepsilon\\}\\) 中的每个符号都给出了相应的 后续状态 (next state) 的集合 \\(S\\) 中一个状态 \\(s_0\\) 被指定为初始状态 \\(S\\) 中一个子集 \\(F\\) 被指定为接受状态集合 我们可以将 NFA 表示为一个转换图, 图中的结点是状态, 带有标号的边表示自动机的转换函数, 这个图与转台转换图十分相似, 但还是有一些区别的 同一个符号可以标记从同一状态出发到达多个目标状态的多条边 一条边的符号不仅可以是输入字母表中的符号, 也可以是空串 除了转换图, 我们也可以将 NFA 表示为一张转换表, 表的各行对应与状态, 各列对应于输入符号和 \\(\\varepsilon\\) 。对应于一个给定状态和给定输出的条目是将 NFA 的转换函数应用于这些参数后得到的值, 如果转换函数没有没有相关信息, 那么我们就将 \\(\\emptyset\\) 填入相应的位置。如下表就是上图的转换表形式 状态 a b \\(\\varepsilon\\) 0 {0, 1} {0} \\(\\emptyset\\) 1 \\(\\emptyset\\) {2} \\(\\emptyset\\) 2 \\(\\emptyset\\) {3} \\(\\emptyset\\) 3 \\(\\emptyset\\) \\(\\emptyset\\) \\(\\emptyset\\) 在转换表上, 我们可以很容易确定, 一个给定状态和一个输入符号相对应的转换; 但是如果输入字母表很大, 且大多数状态在大多数输入字符上没有转换时, 转换表需要占用大量的空间 ","date":"2020-07-16","objectID":"/2020/compilerprinciple_002/:3:1","tags":["笔记","龙书"],"title":"编译原理 (2) – 词法分析1","uri":"/2020/compilerprinciple_002/"},{"categories":["编译原理"],"content":"确定的有穷状态机 DFA 是 NFA 的一个特例, 主要体现在 没有输入 \\(\\varepsilon\\) 之上的转换动作 对每个状态 s 和每个输入符号 a, 有且只有一条标号为 a 的边离开 s NFA 抽象地表示了用来识别某个语言中的串的算法, DFA 则是一个简单具体的识别串的算法, 在构造词法分析器的时候我们使用的是 DFA。 ","date":"2020-07-16","objectID":"/2020/compilerprinciple_002/:3:2","tags":["笔记","龙书"],"title":"编译原理 (2) – 词法分析1","uri":"/2020/compilerprinciple_002/"},{"categories":["编译原理"],"content":"从正则表达式构造NFA 现在我们给出一个算法, 将任何正则表达式转换为接受相同语言的NFA, 这个算法是 语法制导 的, 对于每个子表达式该算法构造一个只有一个接受状态的NFA。 McMaughton-Yamada-Thompson 算法 输入：字母表 \\(\\Sigma\\) 上的一个正则表达式 r 输出：一个接受 L(r) 的 NFA N 方法：首先对r进行语法分析, 分解出组成它的子表达式。构造一个NFA的规则分为 基本规则 和 归纳规则 。基本规则处理不包含运算符的子表达式, 而归纳规则根据一个给定的表达式的直接子表达式的NFA构造出这个表达式的NFA 基本规则: 构造NFA, 其中 i 是一个新状态, 也是这个NFA的开始状态; f 是另一个新状态, 也是这个NFA的接受状态。对于表达式 \\(\\varepsilon\\) 以及字母表 \\(\\Sigma\\) 中的子表达式 a, 构造以下 NFA 归纳规则: 假设正则表达式 s 和 t 的 NFA 分别为 N(s) 和 N(t), 表达式 r 的 NFA 为 N(r) 假设 r = s|t, 构造 N(r), 可以得到从 i 到 N(s) 或 N(t) 的开始状态各有一个 \\(\\varepsilon\\) 转换, 从 N(s) 和 N(t) 的接受状态到 f 也各有一个 \\(\\varepsilon\\) 转换。因为从 i 到 f 的任何路径要么只通过 N(s), 要么只通过 N(t), 且离开 i 或进入 f 的 \\(\\varepsilon\\) 转换都不会改变路径上的标号, 因此我们可以判定 N(r) 识别 \\(L(s) \\cup L(t)\\), 即 \\(L( r)\\) 假设 r = st, 构造 N(r), N(s) 的开始状态变为了 N(r) 的开始状态, N(t) 的接受状态变成了 N(r) 唯一接受状态, N(s) 的接受状态和 N(t) 的开始状态合并为一个状态, 合并后的状态拥有原来进入和离开合并前的两个状态的全部转换。 假设 r = \\(s^{*}\\), 构造 N(r), i 和 f 是两个新状态, 分别为 N(r) 的开始状态和唯一的接受状态。要从i到达f我们需要沿着新引入的标号为 \\(\\varepsilon\\) 的路径前进, 这个路径对应 \\(L(s)^{0}\\) 中的一个串。我们也可以到达 N(s) 的开始状态, 然后经过该 NFA, 在零次或多次从它的接受状态回到它的开始状态并重复上述过程。 r = (s), 那么 L(r) = L(s), 我们可以直接把 N(s) 当作 N(r)。 N(r) 接受语言 L(r) 之外, 构造得到的 NFA 还具有以下性质: N(r) 的状态数最多为 r 中出现的 运算符 和 运算分量 的总数的 2倍, 因为算法的每一个构造步骤最多只引入两个新状态。 N(r) 有且只有一个开始状态和一个接受状态。 N(r) 中除接受状态之外的每个状态要么有一条其标号为 \\(\\Sigma\\) 中符号的出边, 要么有两条标号为 \\(\\varepsilon\\) 的出边。 ","date":"2020-07-16","objectID":"/2020/compilerprinciple_002/:3:3","tags":["笔记","龙书"],"title":"编译原理 (2) – 词法分析1","uri":"/2020/compilerprinciple_002/"},{"categories":["编译原理"],"content":"NFA 到 DFA 我们需要将 NFA 转换为 DFA, 一般采用 子集构造法 直接模拟 NFA。子集构造法的基本思想是让构造得到的 DFA 的每个状态对应于 NFA 的一个状态集合。DFA 的状态数有可能是 NFA 状态数的指数, 不过对于真实的语言, NFA 与 DFA 的状态数量大致相同。 子集构造算法 输入：一个 NFA N 输出：一个接受同样语言的 DFA D 方法：我们为 D 构造一个转换表 Dtran 。D的每个状态是一个 NFA 的状态集, 我们构造 Dtran 使得 D 并行的模拟 N 在遇到一个给定输入串时可能执行的所有动作。在读入第一个输入符号之前, N 位于 \\(\\varepsilon-closure(s_0)\\) 中的任何状态上。假定 N 在读入字符串 x 后位于集合 T 的状态上, 那么下一个输入符号 a, N 可以移动到集合 \\(move(T, a)\\) 中的任何状态。 操作 描述 \\(\\scriptsize \\varepsilon-closure(s)\\) 从 NFA 的状态 s 开始只通过 \\(\\varepsilon\\) 转换到达的 NFA 状态集合 \\(\\scriptsize \\varepsilon-closure(T)\\) 从 T 中某个 NFA 状态 s 开始只通过 \\(\\varepsilon\\) 转换到达的 NFA 状态集合, 即 \\(\\cup_{s \\in T} \\varepsilon-closure(s)\\) \\(move(T,a)\\) 从 T 中某个状态 s 出发通过标号 a 的转换到达的 NFA 状态的集合 简单的说, NFA 中起始状态与起始状态经过 \\(\\varepsilon\\) 转换后所到达的所有状态, 这些状态所组成的集合就是转换成 DFA 的起始状态, 而这个集合中的所有状态分别经过某一路径转换和转换后再经过 \\(\\varepsilon\\) 转换的状态组成了另一个 DFA 状态, 以此下去构成了所有 DFA 中的所有状态 我们继续以上图 \\((a|b)^{*}abb\\) 为例进行从 NFA 到 DFA 的装换, 起始状态 A 为 \\(\\varepsilon-closure(0)\\), 即 \\(A=\\{0, 1, 2, 4, 7\\}\\), 而输入字母表为 \\(\\{a, b\\}\\), 那么接下来分别计算 \\(Dtran[A, a] = \\varepsilon-closure(move(A,a))\\) 以及 \\(Dtran[A, b] = \\varepsilon-closure(move(A,b))\\) 分别得到 DFA 的状态 B 与状态 C, 最终依次计算, 我们会得到一张 NFA 与 DFA 对应关系表 (下表), 这样就可能很轻松的完成 NFA 向 DFA 的转换 DFA 状态 NFA 状态集 经过 a 转换得到的状态 经过 b 转换得到的状态 A {0,1,2,4,7} B C B {1,2,3,4,6,7,8} B D C {1,2,4,5,6,7} B C D {1,2,4,5,6,7,9} B E E {1,2,4,5,6,7,10} B C ","date":"2020-07-16","objectID":"/2020/compilerprinciple_002/:3:4","tags":["笔记","龙书"],"title":"编译原理 (2) – 词法分析1","uri":"/2020/compilerprinciple_002/"},{"categories":["编译原理"],"content":"GiniShio | 编译原理第一章读书笔记","date":"2020-07-14","objectID":"/2020/compilerprinciple_001/","tags":["笔记","龙书"],"title":"编译原理 (1) – 编译器与程序设计语言","uri":"/2020/compilerprinciple_001/"},{"categories":["编译原理"],"content":"编译器 编译器, 是一个 程序, 它可以阅读以某一 源语言 编写的程序, 并把该程序翻译成一个 等价的 、 用 目标语言 编写的程序; 解释器，是另一种语言处理器, 它直接利用用户提供的输入执行源程序中指定的操作。 编译器产生的机器语言目标程序通常比一个解释器 快 得多, 但是解释器的 错误诊断效果 比编译器更好, 因为解释器是逐个语句地执行源程序。 ","date":"2020-07-14","objectID":"/2020/compilerprinciple_001/:1:0","tags":["笔记","龙书"],"title":"编译原理 (1) – 编译器与程序设计语言","uri":"/2020/compilerprinciple_001/"},{"categories":["编译原理"],"content":"基本组成 编译器是由 预处理器 (preprocessor)、 编译器 (compiler)、 汇编器 (assembler)、 链接器 (linker) 这几大主要部分组成, 最后生成一个可执行程序 (executable)。 预处理器: 主要负责文本替换或巨集展开 编译器: 可能产生一个汇编语言的中间代码作为其输出, 因为汇编语言比较容易 输出 和 调试 汇编器: 将编译器产生的中间结果生成 可重新定位的 机器代码 链接器: 将一个或多个由编译器或汇编器生成的目标文件外加库, 链接为一个可执行文件 现代编译器中, 基本可以分步骤调用编译器的各个部分, 生成所需要的阶段输出, 以 gcc 和 clang 为例 预处理 (-E): 输出文件经过预处理器生成的源代码, 一般以 .i 作为文件扩展名 编译 (-S): 将源代码或预处理文件编译生成汇编代码, 汇编代码后缀名 .s 汇编 (-c): 将源代码或之前步骤生成的中间代码汇编生成可重新定位的机器码, 文件后缀名为 .o 链接: 将源文件或之前步骤生成的中间代码链接生成可执行程序 ","date":"2020-07-14","objectID":"/2020/compilerprinciple_001/:1:1","tags":["笔记","龙书"],"title":"编译原理 (1) – 编译器与程序设计语言","uri":"/2020/compilerprinciple_001/"},{"categories":["编译原理"],"content":"结构 编译器由两部分组成, 分析 部分和 综合 部分 分析: 将源程序分解成为多个组成元素, 并在要素之上加上语法结构。分析部分被称为编译器的 前端 综合: 根据中间表示和符号表中的信息来构造用户期待的目标程序。综合部分被称为编译器的 后端 词法分析 (lexical analysis): 词法分析器读入组成源程序的字符流, 并将它们组成成为有意义的 词素 (lexeme) 的序列。对于每个词素, 词法分析器产生如下形式的 词法单元 (token) 作为输出 \u003ctoken-name, attribute-value\u003e 语法分析 (syntax analysis): 语法分析器使用由词法分析器生成的各个词法单元的第一个分量来创建树形的中间表示, 该中间表示给出了词法分析产生的词法单元流的语法结构。常用表示方法为 语法树 (syntax tree), 树中的每个内部接点表示一个运算, 而该结点的子结点表示该运算的分量 语义分析 (semantic analysis): 使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。同时也会收集类型信息, 并把这些信息存放在语法树或符号表中 中间代码生成: 编译器一般在语法分析、语义分析结束之后, 会生成一个明确的低级的或类机器语言的中间表示, 该中间表示应该 易于生成 、且可以被 轻松翻译 为目标机器语言 代码优化: 机器无关的代码优化步骤试图改进中间代码, 以便生成 更好 的目标代码 代码生成: 以源程序的中间表示形式作为输入, 并把它映射到目标语言, 代码生成必须要 合理分配寄存器 符号表管理: 记录源程序中使用的变量名称, 并收集和每个名字的各种属性有关的信息, 这些属性一般包含 存储分配 、 类型 、 作用域 等 ","date":"2020-07-14","objectID":"/2020/compilerprinciple_001/:1:2","tags":["笔记","龙书"],"title":"编译原理 (1) – 编译器与程序设计语言","uri":"/2020/compilerprinciple_001/"},{"categories":["编译原理"],"content":"构造工具 除通用软件开发工具外, 编译器的实现一般需要专业的工具来实现, 这些专用工具使用专用的语言来 描述 和 实现 特定的组件, 这些生成器会隐藏相当复杂的生成算法细节, 并生成易于与其他部分集成的组件 语法分析器的生成器: 可以根据一个程序设计语言的语法描述自动生成语法分析器 扫描器的生成器: 可以根据一个语言的语法单元的正则表达式描述生成词法分析器 语法执导的翻译引擎: 可以生成一组用于遍历分析树并生成中间代码的程序 代码生成器的生成器: 根据一组关于如何把中间语言的每个运算翻译成为目标机上的机器语言的规则, 生成一个代码生成器 数据流分析引擎: 可以帮助收集数据流信息, 即程序中的值如何从程序的一部分传递到另一部分, 这是代码优化的重要部分 编译器构造工具集: 用于构造编译器不同阶段的例程的完整集合 ","date":"2020-07-14","objectID":"/2020/compilerprinciple_001/:1:3","tags":["笔记","龙书"],"title":"编译原理 (1) – 编译器与程序设计语言","uri":"/2020/compilerprinciple_001/"},{"categories":["编译原理"],"content":"程序设计语言 20 世纪 40 年代, 第一台计算机问世, 它使用 01 序列组成的机器语言编程, 直到现在计算机的最底层依然以这种方式运行。但这种编程速度 慢 且 枯燥, 容易出错, 写出的程序 难以 修改与理解。 20 世纪 50 年代早期, 人们开始对助记汇编语言开发, 汇编语言已开始仅是对机器语言的助记表示, 后来加入了 宏指令, 可以为频繁使用的机器指令序列定义带有参数的缩写。 之后, 程序设计语言从汇编语言开始走向高级语言, 用于科学计算的 Fortran 、 用于商业数据处理的 Cobol 、 用于符号计算的 Lisp 等等, 随着时间的推移, 越来越多带着新特性的高级语言被开发出来, 它们更加 简单 、 自然 、 强大 。 根据时间与应用关系, 龙书将程序设计语言分为了 5 代 第一代: 机器语言 第二代: 汇编语言 第三代: 高级程序设计语言, 例如 Fortran、C、C++、Java 等 第四代: 为特定应用设计的语言, 例如用于数据库查询的 SQL, 用于文字排版的 Postscript 第五代: 基于逻辑和约束的语言, 例如 Prolog 和 OPS5 根据程序编程范式的不同, 分为 2 种 强制式 (imperative): 又称 命令式, 程序指明如何完成一个计算任务, 所有强制式语言都有表示 程序状态 和 语句 的表示方法, 语句可以改变程序状态, 例如 C、C++等 声明式 (declarative): 程序指明需要进行哪些运算, 例如 函数式程序设计语言 和 Prolog 等 ","date":"2020-07-14","objectID":"/2020/compilerprinciple_001/:2:0","tags":["笔记","龙书"],"title":"编译原理 (1) – 编译器与程序设计语言","uri":"/2020/compilerprinciple_001/"},{"categories":["编译原理"],"content":"环境与状态 标识符 (identifier) 是一个字符串, 它通常由子母、数字和下划线组成, 它被用来标记一个 实体, 例如 数据对象 、 过程 、 类型 等。变量指向存储中的某一个特定位置, 同一个标识符可能被多次声明 (例如在递归过程中的局部变量), 每一个这样的声明都会引入一个新的变量。所有的标识符都是名字, 不过名字不一定是标识符, 比如 x.y 这样的名字被称为 受限名字 (qualified name), 表示变量 x 所指向结构中的字段 y。 名字和内存 (存储) 位置的关联, 以及之后和值的关联可以用两个映射来描述, 这两个映射随着程序的运行而改变。 环境 (environment) 是从一个名字到存储位置的映射, 例如 C 语言中的右值; 状态 (state) 是一个内存位置到它们值的映射, 例如 C 语言中左值所对应的右值 大多数环境和状态是 动态绑定 的, 一般全局变量的环境映射是静态的, 编译器可以在生成目标代码的时候为其分配一个地址; 常量的声明一般其状态是静态绑定的, 我们看到这个语句时就能确定绑定关系, 并且在程序的运行时这个绑定不能改变。 ","date":"2020-07-14","objectID":"/2020/compilerprinciple_001/:2:1","tags":["笔记","龙书"],"title":"编译原理 (1) – 编译器与程序设计语言","uri":"/2020/compilerprinciple_001/"},{"categories":["编译原理"],"content":"静态与动态 允许编译器静态决定某个问题时, 或者说这个问题可以在 编译时 (compile time) 决定, 我们称这个语言使用了 静态策略 (static policy)。一个问题只允许在 运行时 (run time) 做出决定, 那么称之为 动态策略 (dynamic policy)。比如 C++中的模板计算就是静态策略, 而多继承中的多态则是动态策略。 作用域 (scope) 也需要关注静态还是动态, 如果仅通过阅读程序即可确定一个声明的作用域, 即在编译时就可确定其作用域, 那么这个语言使用 静态作用域, 或者说是 词法作用域 (lexical scope)。否则, 这个语言使用 动态作用域, 如果使用动态作用域, 在程序运行时, 同一个对 x 的使用会指向 x 的几个声明之一。或者简单的说, 静态作用域关注在 何处定义, 动态作用域关注 何处声明 或 何处调用 a=1; function foo() { echo $a; # 静态作用域输出1, 动态作用域输出2 } function bar() { a=2; foo; } bar; ","date":"2020-07-14","objectID":"/2020/compilerprinciple_001/:2:2","tags":["笔记","龙书"],"title":"编译原理 (1) – 编译器与程序设计语言","uri":"/2020/compilerprinciple_001/"},{"categories":["编译原理"],"content":"参数的传递机制 值调用 (call-by-value), 在调用过程中会对实参进行求值或拷贝, 被调用过程中所有有关形式参数的计算被局限于这一过程中, 实参本身不会被影响 引用调用 (call-by-reference), 在调用过程中, 以实参的地址作为形参的值传递给被调用者, 在使用时就会直接使用这个内存地址, 因此形参被修改会影响到实参本身 ","date":"2020-07-14","objectID":"/2020/compilerprinciple_001/:2:3","tags":["笔记","龙书"],"title":"编译原理 (1) – 编译器与程序设计语言","uri":"/2020/compilerprinciple_001/"},{"categories":null,"content":"友情连接 我的博客信息 名称： GinShio 简介： VENI VIDI VICI 地址： https://blog.ginshio.org/ 头像： https://blog.ginshio.org/avatar.png ","date":"0001-01-01","objectID":"/links/:0:0","tags":null,"title":"友人帐","uri":"/links/"}]