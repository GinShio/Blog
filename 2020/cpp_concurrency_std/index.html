<!DOCTYPE html>
<html lang="">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>C&#43;&#43; Concurrency (1) – 标准库 - iris</title><meta name="Description" content="GinShio | Cpp Concurrency in Action (2rd) 第二、三、四章读书笔记"><meta property="og:title" content="C&#43;&#43; Concurrency (1) – 标准库" />
<meta property="og:description" content="GinShio | Cpp Concurrency in Action (2rd) 第二、三、四章读书笔记" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.ginshio.org/2020/cpp_concurrency_std/" />
<meta property="og:image" content="https://blog.ginshio.org/logo.png"/>
<meta property="article:published_time" content="2020-12-01T19:42:00+08:00" />
<meta property="article:modified_time" content="2020-12-08T17:25:30+08:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://blog.ginshio.org/logo.png"/>

<meta name="twitter:title" content="C&#43;&#43; Concurrency (1) – 标准库"/>
<meta name="twitter:description" content="GinShio | Cpp Concurrency in Action (2rd) 第二、三、四章读书笔记"/>
<meta name="application-name" content="iris">
<meta name="apple-mobile-web-app-title" content="iris"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://blog.ginshio.org/2020/cpp_concurrency_std/" /><link rel="prev" href="https://blog.ginshio.org/2020/haskell_function/" /><link rel="next" href="https://blog.ginshio.org/2020/cpp_concurrency_atomic/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><meta name="google-site-verification" content="3DtrOvI7RNNMN-_7YHUNA58kZEgHJ5Qxh4nPZaCmLHk" /><meta name="msvalidate.01" content="62D7DBD61D766DFB9EFEBFD7930695B8" /><meta name="baidu-site-verification" content="tSdWk62L4KBQIcLW" /><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "C++ Concurrency (1) – 标准库",
        "inLanguage": "",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/blog.ginshio.org\/2020\/cpp_concurrency_std\/"
        },"image": ["https:\/\/blog.ginshio.org\/images\/screenshot.png"],"genre": "posts","keywords": "Concurrency, 笔记, 编程语言","wordcount":  7045 ,
        "url": "https:\/\/blog.ginshio.org\/2020\/cpp_concurrency_std\/","datePublished": "2020-12-01T19:42:00+08:00","dateModified": "2020-12-08T17:25:30+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "GinShio","logo": "https:\/\/blog.ginshio.org\/logo.png"},"author": {
                "@type": "Person",
                "name": "GinShio"
            },"description": "GinShio | Cpp Concurrency in Action (2rd) 第二、三、四章读书笔记"
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('light' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'light' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="iris"><span class="header-title-pre"><i class='fas fa-terminal fa-fw'></i></span>iris</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"><i class="fa fa-archive faa-wrench"></i> 归档 </a><a class="menu-item" href="/tags/"><i class="fa fa-tag faa-wrench"></i> 标签 </a><a class="menu-item" href="/categories/"><i class="fa fa-folder-open faa-wrench"></i> 分类 </a><a class="menu-item" href="/about/"><i class="fa fa-info-circle faa-wrench"></i> 关于 </a><a class="menu-item" href="/links/"><i class="fa fa-user-friends faa-wrench"></i> 友人帐 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="iris"><span class="header-title-pre"><i class='fas fa-terminal fa-fw'></i></span>iris</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title=""><i class="fa fa-archive faa-wrench"></i>归档</a><a class="menu-item" href="/tags/" title=""><i class="fa fa-tag faa-wrench"></i>标签</a><a class="menu-item" href="/categories/" title=""><i class="fa fa-folder-open faa-wrench"></i>分类</a><a class="menu-item" href="/about/" title=""><i class="fa fa-info-circle faa-wrench"></i>关于</a><a class="menu-item" href="/links/" title=""><i class="fa fa-user-friends faa-wrench"></i>友人帐</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content always-active" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">C&#43;&#43; Concurrency (1) – 标准库</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://blog.ginshio.org/" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>GinShio</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/c++/"><i class="far fa-folder fa-fw"></i>C++</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2020-12-01">2020-12-01</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 7045 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 15 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#线程管理">线程管理</a>
      <ul>
        <li><a href="#创建线程">创建线程</a></li>
        <li><a href="#传递参数">传递参数</a></li>
        <li><a href="#线程标识">线程标识</a></li>
      </ul>
    </li>
    <li><a href="#共享数据">共享数据</a>
      <ul>
        <li><a href="#条件竞争">条件竞争</a></li>
        <li><a href="#互斥量">互斥量</a>
          <ul>
            <li><a href="#死锁">死锁</a></li>
            <li><a href="#灵活的管理锁">灵活的管理锁</a></li>
          </ul>
        </li>
        <li><a href="#保护共享数据的方式">保护共享数据的方式</a>
          <ul>
            <li><a href="#保护共享数据的初始化过程">保护共享数据的初始化过程</a></li>
            <li><a href="#保护不常更新的数据结构">保护不常更新的数据结构</a></li>
            <li><a href="#重入锁">重入锁</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#同步操作">同步操作</a>
      <ul>
        <li><a href="#等待条件">等待条件</a></li>
        <li><a href="#future">future</a>
          <ul>
            <li><a href="#异步返回值">异步返回值</a></li>
            <li><a href="#绑定任务">绑定任务</a></li>
            <li><a href="#promise">Promise</a></li>
          </ul>
        </li>
        <li><a href="#限时等待">限时等待</a>
          <ul>
            <li><a href="#时钟">时钟</a></li>
            <li><a href="#时间段">时间段</a></li>
            <li><a href="#时间戳">时间戳</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="线程管理">线程管理</h2>
<h3 id="创建线程">创建线程</h3>
<p>新的线程会在 <code>::std::thread</code> (头文件 <em>thread</em> 中) 对象创建的时候被启动，在函数执行完毕后，该线程也就结束了，提供的函数对象会复制到新线程的存储空间中，函数对象的执行与操作都在线程的内存空间中执行。在创建新线程时你可以指定一个函数作为任务，或者是 <strong>仿函数</strong> ，当然也可以是 lambda 表达式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">my_thread0</span><span class="p">{</span><span class="n">do_something</span><span class="p">};</span>
<span class="k">struct</span> <span class="nc">Task</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">do_something</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">my_thread1</span><span class="p">{</span><span class="n">Task</span><span class="p">()};</span>
<span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">my_thread2</span><span class="p">{[]()</span> <span class="p">{</span>
    <span class="n">do_something</span><span class="p">();</span>
<span class="p">}};</span>
</code></pre></td></tr></table>
</div>
</div><p>线程启动后，需要指定是 <code>等待线程结束</code> 还是 <code>让其自主运行</code> ，如果 ::std::thread 对象销毁之前没有做出决定，程序就会终止，因此必须确保线程能够正确 <strong>汇入</strong> (joined) 或 <strong>分离</strong> (detached)。调用 join() 可以等待线程完成，并在线程结束时清理相关的内存，使 ::std::thread 对象不再与已完成线程有任何关联，所以一个线程一旦被汇入将不能再次汇入。调用 detach() 会使线程在后台运行，不再与主线程进行直接交互， ::std::thread 对象不再引用这个线程，分离的线程也不可被再次汇入，不过C++运行时库保证线程退出时可以正确回收相关资源。</p>
<p>在C++中 ::std::thread 对象是一种 <strong>可移动但不可复制</strong> 的资源，它可以交出它的所有权，但不能与其他对象共享线程的所有权。如果你希望对一个已持有线程的对象更改其行为，那你必须先汇入或分离已关联的线程，或者将已关联的线程的所有权交出。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">{</span><span class="n">do_something</span><span class="p">};</span>
<span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">{</span><span class="n">some_other_function</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t3</span><span class="p">;</span>
<span class="n">t3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t2</span><span class="p">);</span>
<span class="c1">// t1 = std::move(t3); // 错误
</span></code></pre></td></tr></table>
</div>
</div><h3 id="传递参数">传递参数</h3>
<p>向线程中传递参数十分简单，为 ::std::thread 构造函数附加参数即可，所有参数 将会拷贝到新线程的内存空间中，即使函数中的参数是引用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">);</span>
<span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">{</span><span class="n">f1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">{</span><span class="s">&#34;Hello&#34;</span><span class="p">}};</span>
<span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="c1">// ::std::thread t2{f2, 2, ::std::string{&#34;Hello&#34;}}; // 报错
</span><span class="c1">// t2.join();
</span></code></pre></td></tr></table>
</div>
</div><p>这里 f2 期望传入一个::std::string的引用，传递参数时会将拷贝的参数以右值的方式进行传递 (为了支持移动的类型)，与函数期望的非常量引用不符，故会在编译期报错。不过我们可以使用 <code>::std::ref</code> 将参数转换为引用的形式进行传递</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="k">auto</span> <span class="n">s</span> <span class="o">=</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">{</span><span class="s">&#34;Hello&#34;</span><span class="p">};</span>
<span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">{</span><span class="n">f2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">s</span><span class="p">)};</span>
<span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div><p>当然也可以在一个线程上运行一个成员函数，做法也是很简单的，第一个参数传递成员函数的指针，第二个参数传递这个类的对象的指针，剩下的则是这个待运行的函数的参数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="k">struct</span> <span class="nc">X</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="nf">do_something</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="p">}</span> <span class="n">x</span><span class="p">;</span>
<span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t3</span><span class="p">{</span><span class="o">&amp;</span><span class="n">X</span><span class="o">::</span><span class="n">do_something</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="线程标识">线程标识</h3>
<p>线程的标识类型是 <code>::std::thread ::id</code> ，可以使用 ::std::thread 对象的成员函数 <code>get_id()</code> 获取，当线程没有和任何执行线程关联时将返回默认值来表示 <strong>无线程</strong>; 也可以使用 <code>::std::this_thread::get_id()</code> 来获取当前线程的标识。::std::thread ::id 对象可以拷贝或对比，因为标识符是可复用的，当两个标识符相等时代表 <strong>同一个线程</strong> 或这两个线程 <strong>无关联线程</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="k">if</span> <span class="p">(</span><span class="n">master_thread_id</span> <span class="o">==</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">master_do_something</span><span class="p">();</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">worker_do_something</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><hr>
<h2 id="共享数据">共享数据</h2>
<p>涉及到共享数据时，问题就是因为共享数据的修改所导致，如果共享数据只读，那么不会影响到数据，更不会对数据进行修改，所有线程都会获得同样的数据。但当一个或多个线程要修改共享数据时，就会产生很多麻烦，需要小心谨慎，才能确保所有线程都正常工作。</p>
<h3 id="条件竞争">条件竞争</h3>
<p>并发中的竞争条件，取决于一个以上线程的执行顺序，每个线程都抢着完成自己的任务，大多数情况下，即使改变执行顺序，也是良性竞争，结果是可以接受的。遗憾的是，当不变量遭到破坏时会产生条件竞争，通常是恶性竞争：并发的去修改一个独立对象。恶性竞争时对一个数据块进行修改时，其他线程可能同时对其进行访问，导致数据不一致或与预期不符，并且出现概率低且难复现。</p>
<p>避免恶性竞争，最简单的方法就是对数据结构采用某种 <strong>保护机制</strong>, 确保只有修改线程可以看到不变量的中间状态，其他线程观察结构时会发现其修改还未开始。另一方式就是对数据结构与不变量进行修改，修改后的结构可以完成一系列不可分割的变量，从而保证不变量的状态，即 <strong>无锁编程</strong> 。</p>
<h3 id="互斥量">互斥量</h3>
<p>访问共享数据前将数据锁住，在访问结束后再将数据解锁，当线程使用互斥量锁住共享数据时，其他的线程都必须等到之前那个线程对数据进行解锁后，才能进行访问数据。</p>
<p>通过实例化 <code>::std::mutex</code> (头文件 <em>mutex</em> 中) 创建互斥量实例，成员函数lock()可对互斥量上锁，unlock()为解锁，不过不推荐使用成员函数，因为你必须在函数的出口处正确的解锁，其中包括异常情况也必须保证正确解锁，否则互斥量可能无法正常使用。推荐的做法是使用互斥量RAII模板类 <code>::std::lock_guard</code> (头文件 <em>mutex</em> 中)，构造时加锁并在析构时解锁，保证互斥量可以被正确的解锁。</p>
<p>下面例子中，如果多个线程访问add_n函数，那么互斥量mu就会保护变量 <code>result</code> ，在一个线程中修改它时其他线程将无法访问它， \(result += i\) 将会在线程中安全的执行，不会因为数据竞争导致线程看到的result脏值，从而污染结果</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mu</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">add_n</span><span class="p">(</span><span class="k">const</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">&amp;</span> <span class="n">n</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">&amp;</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1ll</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">(</span><span class="n">mu</span><span class="p">);</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>不过通常互斥量会与需要保护的数据封装在同一个类中，让它们联系在一起，保证数据不变量的稳定状态。不过当类中某个方法返回保护数据的指针或者引用时，可能会破坏数据，此时需要谨慎的对接口进行设计，切勿将受保护数据的指针或引用传递到互斥锁作用域之外。</p>
<p>使用互斥量保护数据时，还需要考虑接口间的条件竞争，比如常使用的 ::std::stack，以下代码在单线程中是正确的，但是当 ::std::stack 是共享数据时，虽然每次调用接口时内部可能返回正确的结果，但是当用户使用时可能并非安全的。很明显代码中，top() 调用时很可能其他线程已经 pop() 了最后一个元素，虽然该线程访问到栈不为空，但是 top() 获取到错误的结果， <code>top()</code> 与 <code>pop()</code> 存在数据竞争关系</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
    <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="n">do_something</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>锁的粒度太小，恶性条件竞争已经出现，需要保护的操作并未全覆盖到; 如果锁的粒度太大，会抵消并发带来的性能提升。</p>
<h4 id="死锁">死锁</h4>
<p>使用多个互斥量操作时需要注意 <strong>死锁</strong> ，这会让两个线程互相等待，直到另一个解锁互斥量。死锁产生的必要条件:</p>
<ol>
<li><strong>互斥条件</strong> ：一个资源每次只能被一个任务使用</li>
<li><strong>占有且等待</strong> ：因请求资源而阻塞时，对已获得的资源保持不放</li>
<li><strong>不可剥夺</strong> ：已获得的资源，在末使用完之前，不能强行剥夺</li>
<li><strong>循环等待条件</strong> ：若干任务之间形成一种头尾相接的循环等待资源关系</li>
</ol>
<p>一般在C++使用互斥量时，避免循环等待即可，对多个互斥量可以使用标准库中的 <code>::std::lock</code> 与 <code>::std::lock_guard</code> 进行RAII锁定，可以按照一定的顺序对互斥量进行锁定，避免循环锁定。以下代码展示了一次锁定多个互斥量，::std::lock 锁定互斥量，并创建两个 ::std::lock_guard 对象对互斥量进行管理，=::std::adopt_lock= 表示 ::std::lock_guard 可以获取锁并将锁交给其管理，::std::lock_guard 对象不需要再构建新的锁。值得一提的是，::std::lock 可能会抛出异常，但是请放心，已锁定的锁会随着异常而自动释放，所以 ::std::lock 要么 <strong>全部锁住</strong> 要么 <strong>一个都不锁</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">X</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lhs</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">lock</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">mu</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">mu</span><span class="p">);</span>
    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lockl</span><span class="p">{</span><span class="n">lhs</span><span class="p">.</span><span class="n">mu</span><span class="p">,</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">adopt_lock</span><span class="p">};</span>
    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lockr</span><span class="p">{</span><span class="n">rhs</span><span class="p">.</span><span class="n">mu</span><span class="p">,</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">adopt_lock</span><span class="p">};</span>
    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>C++17 中提供了RAII模板类 <code>::std::scoped_lock</code> (头文件 <em>mutex</em> 中) 用来支持这种情况，并且增加了 <strong>自动推导模板参数</strong> ，是所以这种情况在 C++17 中将会更简单的实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">X</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lhs</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">scoped_lock</span> <span class="n">guard</span><span class="p">{</span><span class="n">lhs</span><span class="p">.</span><span class="n">mu</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">mu</span><span class="p">};</span>
    <span class="c1">// 等价于:
</span><span class="c1"></span>    <span class="c1">// ::std::scoped_lock&lt;::std::mutex, ::std::mutex&gt; guard{lhs.mu, rhs.mu};
</span><span class="c1"></span>    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>死锁通常是对锁的使用不当造成，当然也可以是其他情况，不过我们应该尽可能的避免死锁</p>
<ol>
<li><strong>避免嵌套锁</strong> ：获取一个锁时就别再获取第二个，需要获取多个锁时应使用 ::std::lock 来完成</li>
<li><strong>避免在持有锁时调用外部代码</strong> ：代码是由外部提供的，我们无法确定外部的行为，可能会造成与第一条违反的情况</li>
<li><strong>使用固定顺序获取锁</strong> ：当有多个锁且无法使用 ::std::lock 时，应在每个线程上以固定的顺序获取锁</li>
</ol>
<h4 id="灵活的管理锁">灵活的管理锁</h4>
<p>标准库提供了一种灵活的RAII管理锁的方式 <code>::std::unique_lock</code> (头文件 <em>mutex</em> 中)，它允许使用 <code>::std::adopt_lock</code> 假设已拥有互斥的所有权，也允许使用 <code>::std::defer_lock</code> 假设不获取互斥的所有权，使用 ::std::unique_lock 会与 ::std::lock_guard 的实现方式等价。::std::unique_lock 对象中带有标志来确定是否持有互斥量，并确保正确地在析构函数中处理互斥量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">X</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lhs</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lockl</span><span class="p">{</span><span class="n">lhs</span><span class="p">.</span><span class="n">mu</span><span class="p">,</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">defer_lock</span><span class="p">};</span>
    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lockr</span><span class="p">{</span><span class="n">rhs</span><span class="p">.</span><span class="n">mu</span><span class="p">,</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">defer_lock</span><span class="p">};</span>
    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">lock</span><span class="p">(</span><span class="n">lockl</span><span class="p">,</span> <span class="n">lockr</span><span class="p">);</span> <span class="c1">// 持有的互斥量并锁定
</span><span class="c1"></span>    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>::std::unique_lock 是一种可移动不可复制的类型，它可以交出已持有互斥量的所有权，使互斥量在不同作用域中传递</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">get_lock</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">extern</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mu</span><span class="p">;</span>
    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">{</span><span class="n">mu</span><span class="p">};</span>
    <span class="n">do_something</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">lk</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">other</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">{</span><span class="n">get_lock</span><span class="p">()};</span>
    <span class="n">do_something</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>::std::unique_lock 还支持在对象销毁之前放弃持有互斥，这样可以提前为其他等待线程释放锁，增加性能。</p>
<p>锁的粒度是用来描述锁保护的数据量的大小， <strong>细粒度锁</strong> (fine-grained lock) 能够保护较小的数据量， <strong>粗粒度锁</strong> (coarse-grained lock) 能够保护较多的数据量。比如数据库中，对一行进行锁定的锁比对整张表锁定的锁粒度小，行锁相对于表锁性能更高，因为可以同时处理多行，但是也更不安全。</p>
<h3 id="保护共享数据的方式">保护共享数据的方式</h3>
<h4 id="保护共享数据的初始化过程">保护共享数据的初始化过程</h4>
<p>如果一个资源构造代价昂贵，我们可能会使用延迟初始化来构造它，不过这在单线程下是安全的，多线程下初始化是需要被保护的，不然可能会出现多次初始化的情况</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">{</span><span class="n">mu</span><span class="p">};</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">element</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">lk</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="n">do_something</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>双重检测锁定模式 (DCLP) 也是一种保护初始化的状态，不过遗憾的是，它存在潜在的条件竞争，即线程可能得知其他线程完成了初始化，但可能没有看到新创建的实例，在调用do_something()时得到不正确的结果。Java引入了volatile关键字并安全地实现了DCLP，C++11开始我们也可以实现安全的DCLP。详细可以阅读 <a href="https://www.aristeia.com/Papers/DDJ%5FJul%5FAug%5F2004%5Frevised.pdf" target="_blank" rel="noopener noreffer">C++与双重检测锁定模式的风险</a>，我们也可以在之后的学习中学习安全的DCLP实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="c1">// DCLP
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">{</span><span class="n">mu</span><span class="p">};</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">element</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">do_something</span><span class="p">();</span> <span class="c1">// 数据竞争
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>不过我们可以不这么麻烦，C++标准库为我们提供了 <code>::std::once_flag</code> 与 <code>::std::call_once</code> (头文件 <em>mutex</em> 中) 来处理这种情况，并且相比使用互斥量所消耗的资源更少</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">once_flag</span> <span class="n">once</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">call_once</span><span class="p">(</span><span class="n">once</span><span class="err">，</span><span class="p">[]()</span> <span class="p">{</span>
        <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">element</span><span class="p">();</span>
    <span class="p">});</span>
    <span class="n">do_something</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>局部作用域中的static变量在声明后就已经完成初始化，对于C++11之前初始化的过程中存在条件竞争，但是从 <strong>C++11</strong> 之后开始初始化与定义完全在一个线程中发生</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="n">element</span> <span class="nf">get_element_instance</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">element</span> <span class="n">instance</span><span class="p">;</span> <span class="c1">// C++11 开始为线程安全的初始化
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="保护不常更新的数据结构">保护不常更新的数据结构</h4>
<p>当有不常更新的数据结构时，我们希望在修改时线程可以独占并安全的修改内容，完成修改后可以并发的安全访问数据。使用 ::std::mutex 来保护这样的数据结构对于性能来说并不是一个很好的方法，这会削弱读取数据的性能。我们可以想象这样一种互斥量，它可以在 <strong>写</strong> 线程中独占访问，而允许 <strong>读</strong> 线程并发访问，这样的互斥量被称为 <strong>读写锁</strong> ，读线程需要等写线程释放锁后才可以并发访问，而写线程必须等全部读线程放弃互斥量后才可以独占访问。</p>
<p>C++17标准库提供了 <code>::std::shared_mutex</code> (头文件 <em>shared_mutex</em> 中)，C++14提供了RAII模板类 <code>::std::shared_lock</code> 与有时限的读写锁 <code>::std::shared_timed_mutex</code> (头文件 <em>shared_mutex</em> 中)，可惜的是C++11中并没有提供相应的设施。timed_mutex系列互斥量相比普通互斥量，多了时限功能，在时限内可以获得锁则返回true并获得锁，否则返回false并不能获得锁，不过普通的互斥量则相较有更高的性能。在读写锁的使用中，对于写线程可以使用 ::std::lock_guard&lt;::std::shared_mutex&gt; 与 ::std::unique_lock&lt;::std::shared_mutex&gt; 进行RAII管理，它们与普通的互斥量行为一致；对于读线程，则需要 ::std::shared_lock&lt;::std::shared_mutex&gt; 进行RAII管理</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="k">class</span> <span class="nc">DnsCache</span> <span class="p">{</span>
  <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="err">，</span><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">entries_</span><span class="p">;</span>
  <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span> <span class="n">mu_</span><span class="p">;</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">domain</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">shared_lock</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">{</span><span class="n">mu_</span><span class="p">};</span>
    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">entries_</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">entries_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="o">?</span> <span class="s">&#34;&#34;</span> <span class="o">:</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="k">const</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">domain</span><span class="p">,</span> <span class="k">const</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">ip</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">{</span><span class="n">mu_</span><span class="p">};</span>
    <span class="n">entries_</span><span class="p">[</span><span class="n">domain</span><span class="p">]</span> <span class="o">=</span> <span class="n">ip</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="重入锁">重入锁</h4>
<p>在一个线程上，对已上锁的 ::std::mutex 再次上锁是错误的，会引起未定义行为，如果希望在线程上对一个互斥量在释放前进行多次上锁，则需要使用 <code>::std::recursive_mutex</code> (头文件 <em>mutex</em> 中)。当然要牢记，你对其上锁了多少次，那一定需要解锁多少次，否则就会出现锁死其他线程的情况 (请善用 ::std::lock_guard 与 ::std::unique_lock)</p>
<hr>
<h2 id="同步操作">同步操作</h2>
<h3 id="等待条件">等待条件</h3>
<p>通过一条线程触发等待事件的机制是最基本的唤醒方式，这种机制被称为 <strong>条件变量</strong> ，条件变量与多个事件或其他条件相关，并且一个或多个线程会等待条件的达成。当某些线程被终止时，为了唤醒等待线程，终止线程会向等待着的线程广播信息。</p>
<p>C++标准库实现了条件变量 (头文件 <em>condition_variable</em> 中) <code>::std::condition_variable</code> 和 <code>::std::condition_variable_any</code> ，它们需要与互斥量一起才能工作，前者需要和 ::std::mutex 一起工作，而 _any 后缀的条件变量可以和任何互斥量一起，但是相比普通条件变量更消耗系统资源。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mu</span><span class="p">;</span>
<span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">data_chunk</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
<span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cond</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">preparation</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">more</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">const</span> <span class="n">data_chunk</span> <span class="n">data</span> <span class="o">=</span> <span class="n">get_data</span><span class="p">();</span>
        <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">{</span><span class="n">mu</span><span class="p">};</span>
        <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
        <span class="n">cond</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">processing</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;::</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">{</span><span class="n">mu</span><span class="p">};</span>
        <span class="n">cond</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="p">[]</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">});</span>
        <span class="n">data_chunk</span> <span class="n">data</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">lk</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
        <span class="n">process</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_last_chunk</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>以上代码就是一个条件变量的应用，执行情况如下</p>
<ol>
<li>preparation 线程将获取数据，上锁互斥量并将数据压入队列</li>
<li>processing 线程必须对互斥量进行锁定，之后才能调用条件变量的成员函数 wait() 检查条件谓词，如果成立则继续，如果不成立将解锁互斥量并阻塞当前线程</li>
<li>preparation 线程调用 notify_one() 会唤醒 <strong>一个正在等待</strong> 的线程，调用后需要解锁互斥量，如果没有等待线程则无事发生，notify_one() 不会唤醒调用后开始等待的线程</li>
<li>如果 processing 线程被唤醒，则会重新获取锁，并再次进行条件谓词的检查</li>
</ol>
<p>条件变量调用wait()的过程中，可能会多次检查条件谓词，并在谓词为true的情况下立即返回。另一点，等待线程可能会在不被其他线程通知的情况下被唤醒，这被称为 <strong>虚假唤醒</strong> ，而虚假唤醒的数量和频率都是不确定的，所以条件谓词不建议有副作用。</p>
<h3 id="future">future</h3>
<p>当线程需要等待特定事件时，某种程度上来说就需要知道期望的结果，线程会周期性的等待或检查事件是否触发，检查期间也会执行其他任务。另外，等待任务期间也可以先执行另外的任务，直到对应的任务触发，而后等待future的状态会变为就绪状态。future可能是和数据相关，也可能不是，当事件发生时，这个future就不能重置了。</p>
<p>C++标准库提供了两种future (头文件 <em>future</em> 中) <code>::std::future</code> 和 <code>::std::shared_future</code> ，它们与智能指针 ::std::shared_ptr 和 ::std::unique_ptr 十分类似。::std::future 只能与指定事件相关连，而 ::std::shared_future 可以关联多个事件，而实现中所有实例会同时变为就绪状态，并且可以访问与事件相关的数据。如果希望future与数据无关，则可以使用 <strong>void</strong> 的特化。future 像是线程通信，但是其本身并不提供同步访问，如果需要访问独立的future对象时则需要使用互斥量或类似同步机制进行保护，::std::shared_future 提供访问异步操作结果的机制，每个线程可以安全的访问自身 ::std::shared_future 对象的副本。</p>
<h4 id="异步返回值">异步返回值</h4>
<p>我们可以使用 <code>::std::async</code> (头文件 <em>future</em> 中) 和 ::std::future 启动一个异步任务，获取线程的返回值，当然等待返回值的线程会阻塞，直到 ::std::future 就绪为止</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="nf">async_func</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">do_something</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">async_func</span><span class="p">);</span> <span class="c1">// 异步执行 async_func
</span><span class="c1"></span>    <span class="n">do_something</span><span class="p">();</span>
    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Return: &#34;</span> <span class="o">&lt;&lt;</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">flush</span> <span class="c1">// 立即打印
</span><span class="c1"></span>                <span class="o">&lt;&lt;</span> <span class="n">ret</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 阻塞，直到 future 就绪
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>::std::future 是否需要等待取决于绑定的 ::std::async 是否启动一个线程，或是否有任务正在进行，大多数情况下在函数调用之前可以传递一个 <code>::std::launch</code> 类型的对象</p>
<ul>
<li><strong>::std::launch::defered</strong> ：惰性求值，延迟到 wait() 或 get() 时进行求值</li>
<li><strong>::std::launch::async</strong> ：异步求值，求值将在一个独立的线程上进行</li>
<li><strong>::std::launch::async | ::std::luanch::defered</strong> ：默认行为，惰性求值或异步求值，具体求值方式由实现定义</li>
</ul>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="k">auto</span> <span class="n">f0</span> <span class="o">=</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="n">func0</span><span class="p">);</span> <span class="c1">// 异步求值
</span><span class="c1"></span><span class="k">auto</span> <span class="n">f1</span> <span class="o">=</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">defered</span><span class="p">,</span> <span class="n">func1</span><span class="p">);</span> <span class="c1">// 惰性求值
</span><span class="c1"></span><span class="k">auto</span> <span class="n">f2</span> <span class="o">=</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span> <span class="o">|</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">defered</span><span class="p">,</span> <span class="n">func2</span><span class="p">);</span> <span class="c1">// 求值方式由实现定义
</span><span class="c1"></span><span class="k">auto</span> <span class="n">f3</span> <span class="o">=</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">func3</span><span class="p">);</span> <span class="c1">// 求值方式由实现定义
</span></code></pre></td></tr></table>
</div>
</div><h4 id="绑定任务">绑定任务</h4>
<p><code>::std::packaged_task</code> (头文件 <em>future</em> 中) 允许将 future 与可调用对象进行绑定，::std::packaged_task 的模板参数是一个可调用类型，在调用 ::std::packaged_task 时就会调用相关函数，而 future 状态就绪时则会存储返回值，通过 get_future() 获取绑定的 future 对象。</p>
<h4 id="promise">Promise</h4>
<p>大部分并发编程语言都实现了 <strong>Promise/Future</strong> 结构，起源于函数式编程和相关范例，目的是将值与其计算方式分离，从而允许更灵活地进行计算，特别是通过并行化。后来它在分布式计算中得到了应用，减少了通信往返的延迟。future是变量的 <strong>只读</strong> 占位符视图，而promise是 <strong>可写</strong> 的单赋值容器，用于设置future的值。</p>
<p>类模板 <code>::std::promise</code> (头文件 <em>future</em> 中) 提供存储值或异常的设施，之后通过 ::std::promise 对象所创建的 ::std::future 对象异步获得结果。::std::future 会阻塞等待线程，::std::promise 则会设置结果并将关联的 ::std::future 对象设置为就绪状态，不过 std::promise 只应当使用一次。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">void</span> <span class="nf">accumulate</span><span class="p">(</span><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">first</span><span class="p">,</span>
                <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">last</span><span class="p">,</span>
                <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">accumulate_promise</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">accumulate_promise</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">accumulate_promise</span><span class="p">;</span>
    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">accumulate_future</span> <span class="o">=</span> <span class="n">accumulate_promise</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">work_thread</span><span class="p">(</span><span class="n">accumulate</span><span class="p">,</span> <span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                              <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">accumulate_promise</span><span class="p">));</span>
    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">accumulate_future</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 等待结果
</span><span class="c1"></span>    <span class="n">work_thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>::std::shared_future 可用于同时向多个线程发信息, 类似于 ::std::condition_variable::notify_all()</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">ready_promise</span><span class="p">,</span> <span class="n">t1_promise</span><span class="p">,</span> <span class="n">t2_promise</span><span class="p">;</span>
<span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">shared_future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">ready_future</span><span class="p">{</span><span class="n">ready_promise</span><span class="p">.</span><span class="n">get_future</span><span class="p">()};</span>
<span class="k">using</span> <span class="n">high_resolution_clock</span> <span class="o">=</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="p">;</span>
<span class="k">using</span> <span class="n">milli</span> <span class="o">=</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">;</span>
<span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">time_point</span><span class="o">&lt;</span><span class="n">high_resolution_clock</span><span class="o">&gt;</span> <span class="n">start</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">result1</span> <span class="o">=</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span>
                            <span class="p">[</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">ready_future</span><span class="p">]()</span> <span class="o">-&gt;</span> <span class="n">milli</span> <span class="p">{</span>
                                <span class="n">t1_promise</span><span class="p">.</span><span class="n">set_value</span><span class="p">();</span>
                                <span class="n">ready_future</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span> <span class="c1">// 等待来自 main() 的信号
</span><span class="c1"></span>                                <span class="k">return</span> <span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
                            <span class="p">});</span>
<span class="k">auto</span> <span class="n">result2</span> <span class="o">=</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span>
                            <span class="p">[</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">ready_future</span><span class="p">]()</span> <span class="o">-&gt;</span> <span class="n">milli</span> <span class="p">{</span>
                                <span class="n">t2_promise</span><span class="p">.</span><span class="n">set_value</span><span class="p">();</span>
                                <span class="n">ready_future</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span> <span class="c1">// 等待来自 main() 的信号
</span><span class="c1"></span>                                <span class="k">return</span> <span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
                            <span class="p">});</span>
<span class="n">t1_promise</span><span class="p">.</span><span class="n">get_future</span><span class="p">().</span><span class="n">wait</span><span class="p">();</span>
<span class="n">t2_promise</span><span class="p">.</span><span class="n">get_future</span><span class="p">().</span><span class="n">wait</span><span class="p">();</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
<span class="n">ready_promise</span><span class="p">.</span><span class="n">set_value</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Thread 1 received the signal &#34;</span>
          <span class="o">&lt;&lt;</span> <span class="n">result1</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; ms after start</span><span class="se">\n</span><span class="s">&#34;</span>
          <span class="o">&lt;&lt;</span> <span class="s">&#34;Thread 2 received the signal &#34;</span>
          <span class="o">&lt;&lt;</span> <span class="n">result2</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; ms after start</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="限时等待">限时等待</h3>
<p>阻塞调用会将线程挂起一段不确定的时间，直到相应的事件发生，通常情况下这样的方式很不错，但是在一些情况下，需要限定线程等待的时间。</p>
<p>通常有两种指定超时方式：一种是 <strong>时间段</strong> ，另一种是 <strong>时间点</strong> 。第一种方式，需要指定一段时间；第二种方式，就是指定一个时间点。多数等待函数提供变量，对两种超时方式进行处理，处理持续时间的变量 (<strong>时间段</strong>) 以 <code>_for</code> 作为后缀，处理绝对时间的变量 (时间戳) 以 <code>_until</code> 作为后缀。</p>
<h4 id="时钟">时钟</h4>
<p>时钟就是时间信息源，一个时钟的当前时间可由静态成员函数 <code>now()</code> 获取，特定的时间点的类型是成员类型 <code>time_point</code> 。时钟节拍被指定为1/x秒，这是由时间周期所决定，当时钟节拍均匀分布且不可修改时这种时钟被称为稳定时钟。</p>
<h4 id="时间段">时间段</h4>
<p>时间段 <code>::std::chrono::duration</code> (头文件 <em>chrono</em> 中) 由 Rep 类型的 <strong>计次数</strong> 和 Period 类型的 <strong>计次周期</strong> 组成，计次周期是一个编译期有理数常量，表示从一个计次到下一个的秒数，比如分钟的类型可以使用 <code>::std::chrono::duration&lt;long long, ::std::ratio&lt;60, 1&gt;&gt;</code> 表示，而毫秒的类型可以使用 <code>::std::chrono::duration&lt;long long, ::std::ratio&lt;1, 1000&gt;&gt;</code> 表示。不过为了方便起见，标准库定义了辅助类型来简化使用： <strong>::std::chrono::nanoseconds</strong> (纳秒)、 <strong>::std::chrono::microseconds</strong> (微秒)、 <strong>::std::chrono::milliseconds</strong> (毫秒)、 <strong>::std::chrono::seconds</strong> (秒)、 <strong>::std::chrono::minutes</strong> (分) 和 <strong>::std::chrono::hours</strong> (时)。C++20开始，标准库又增加了天、周、月、年来方便使用时间段。</p>
<p>C++14中， <code>::std::literals</code> 中定义了一些 duration 字面量方便使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="k">using</span> <span class="k">namespace</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">literals</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">one_day</span> <span class="o">=</span> <span class="mi">24</span><span class="n">h</span><span class="p">;</span> <span class="c1">// 24小时
</span><span class="c1"></span><span class="k">auto</span> <span class="n">half_an_hour</span> <span class="o">=</span> <span class="mi">30</span><span class="n">min</span><span class="p">;</span> <span class="c1">// 30分钟
</span><span class="c1"></span><span class="k">auto</span> <span class="n">five_seconds</span> <span class="o">=</span> <span class="mi">5</span><span class="n">s</span><span class="p">;</span> <span class="c1">// 5秒
</span><span class="c1"></span><span class="k">auto</span> <span class="n">one_second</span> <span class="o">=</span> <span class="mi">1000</span><span class="n">ms</span><span class="p">;</span> <span class="c1">// 1000毫秒
</span><span class="c1"></span><span class="k">auto</span> <span class="n">ten_micros</span> <span class="o">=</span> <span class="mi">10u</span><span class="n">s</span><span class="p">;</span> <span class="c1">// 10微秒
</span><span class="c1"></span><span class="k">auto</span> <span class="n">two_nanos</span> <span class="o">=</span> <span class="mi">2</span><span class="n">ns</span><span class="p">;</span> <span class="c1">// 2纳秒
</span></code></pre></td></tr></table>
</div>
</div><h4 id="时间戳">时间戳</h4>
<p>时间戳 <code>::std::chrono::time_point</code> (头文件 <em>chrono</em> 中) 由 Clock 类型的 <strong>时钟</strong> 和 Duration 类型的 <strong>时钟间隔</strong> 组成，并且可以通过算术运算调整时间戳。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">now</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">time_t</span> <span class="n">now_c</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">to_time_t</span><span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">hours</span><span class="p">(</span><span class="mi">24</span><span class="p">));</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;24 hours ago, the time was &#34;</span>
          <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">put_time</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now_c</span><span class="p">),</span> <span class="s">&#34;%F %T&#34;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello World</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Printing took &#34;</span>
          <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">microseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span>
          <span class="o">&lt;&lt;</span> <span class="s">&#34;us.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
<span class="c1">// 24 hours ago, the time was 2020-12-03 23:47:43
</span><span class="c1">// Hello World
</span><span class="c1">// Printing took 4us.
</span></code></pre></td></tr></table>
</div>
</div></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2020-12-08</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/2020/cpp_concurrency_std/index.md" target="_blank">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://blog.ginshio.org/2020/cpp_concurrency_std/" data-title="C&#43;&#43; Concurrency (1) – 标准库" data-hashtags="Concurrency,笔记,编程语言"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://blog.ginshio.org/2020/cpp_concurrency_std/" data-hashtag="Concurrency"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Linkedin" data-sharer="linkedin" data-url="https://blog.ginshio.org/2020/cpp_concurrency_std/"><i class="fab fa-linkedin fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Hacker News" data-sharer="hackernews" data-url="https://blog.ginshio.org/2020/cpp_concurrency_std/" data-title="C&#43;&#43; Concurrency (1) – 标准库"><i class="fab fa-hacker-news fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://blog.ginshio.org/2020/cpp_concurrency_std/" data-title="C&#43;&#43; Concurrency (1) – 标准库"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/line.svg"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://blog.ginshio.org/2020/cpp_concurrency_std/" data-title="C&#43;&#43; Concurrency (1) – 标准库"><i class="fab fa-weibo fa-fw"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/concurrency/">Concurrency</a>,&nbsp;<a href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a>,&nbsp;<a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/2020/haskell_function/" class="prev" rel="prev" title="Haskell 入门 (2) – 函数"><i class="fas fa-angle-left fa-fw"></i>Haskell 入门 (2) – 函数</a>
            <a href="/2020/cpp_concurrency_atomic/" class="next" rel="next" title="C&#43;&#43; Concurrency (2) – 原子操作">C&#43;&#43; Concurrency (2) – 原子操作<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="gitalk" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://github.com/gitalk/gitalk"></a>Gitalk</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.74.3">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2020</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://blog.ginshio.org/" target="_blank">GinShio</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lunr@2.3.8/lunr.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.stemmer.support.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.zh.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":12},"comment":{"gitalk":{"admin":["GinShio"],"clientID":"1ede37779b82f8d8a39e","clientSecret":"4dc775e507be852aa2805c6643495ed7178b7826","id":"2020-12-01T19:42:00+08:00","owner":"GinShio","repo":"Blog","title":"C++ Concurrency (1) – 标准库"}},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"},{"display":false,"left":"$","right":"$"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script type="text/javascript" src="/js/theme.min.js"></script><script type="text/javascript">
            window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());
            gtag('config', 'UA-172480612-1', { 'anonymize_ip': true });
        </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=UA-172480612-1" async></script></body>
</html>
