# Haskell 入门 (2) – 函数


Haskell 中变量是不可变的, 当你定义一个变量之后, 它的值与类型就被固定了, 如果你重复定义, 那么编译时将会报错。如果你是在GHCi中写代码, GHCi更喜欢使用新定义的变量, 并且不会报出重复定义的错误信息。


## 函数 {#函数}


### 基本格式 {#基本格式}

在文件中, 我们在第一行声明函数的名称、类型, 这被称为函数的类型签名, 之后另起一行定义函数, 大致格式如下

```haskell
函数名 :: 参数1类型 -> 参数2类型 -> .. -> 返回值类型
函数名 参数1 参数2 .. = 函数体
```

如果需要类型限定, 使用类型类, 需要在类型签名之前进行限定, 并使用 \\(=>\\) 将限定与签名链接起来, 另外 Haskell 中函数不能以大写字母开始, 否则会被当作 `类型` 或 `类型的值`, 如下

```haskell
function1 :: (Show a, Ord a) => a -> a -> a
function2 :: Show a => Ord a => a -> a -> a
```

如果在 GHCi 中定义函数, 我们之前也已经接触过了, 与 .hs 文件中相当, 不过定义多行函数, 在 GHCi 中需要使用 `:{` 开头, `:}` 结尾的格式来定义

```haskell
:{
week n = case n of
  1 -> "Mon"
  2 -> "Tue"
  3 -> "Wed"
  4 -> "Thu"
  5 -> "Fri"
  6 -> "Sat"
  7 -> "Sun"
  _ -> error "invalid"
:}
:t week -- (Eq a, Num a) => a -> [Char]
week 4 -- "Thu"
```


### 模块 {#模块}

在编写Haskell代码时, 第一行一般会声明一些编译器参数, 如果不需要则可以省略这一行, 之后使用 `module XXX where` 的格式定义模块的名称, 并可以控制对其他模块的可见性。如下定义Test模块, 并有三个函数 f1、f2、f3, 设置f3为私有:

```haskell
module Test (f1, f2) where
f1 = ...
f2 = ...
f3 = ... -- Test模块私有函数
```

import 可以用来导入需要的库、导入库中特定的函数, 或者隐藏一些函数, 甚至可以给你导入的模块起一个别名, 比如说

```haskell
import Test -- 导入模块
import Test (f1) -- 导入Test中的f1
import Test hiding (f1) -- 导入Test模块, 但隐藏f1
import Test as T -- 导入Test模块并赋予别名T
```

如果你并不想导入模块的话, 那么你可以在使用时给出完整的路径

```haskell
Test.f1 ...
```

---


## Lambda {#lambda}

Lambda 表达式是函数的另一种格式, 写法源于 \\(\lambda\\) 演算, 各个函数式编程中 lambda表达式的写法类似, 有如下形式

```haskell
(\参数1 -> \参数2 -> ... -> 函数体)
```

我们构造一个lambda函数, 并应用两个参数 `abs` 与 `(-5)`, 计算过程大致如下

```haskell
(\x -> \y -> x y) (abs) (-5)
-- (\y -> abs y) (-5)
-- abs (-5)
-- 5
```

lambda表达式一般有两个主要应用:

1.  构造一个 **匿名函数** (anonymous function)
2.  对于柯里化函数, 在不给定前一个参数的前提下给定后一个

<!--listend-->

```haskell
map (\x -> x * 2 + 7) [1..10]
-- [9,11,13,15,17,19,21,23,25,27]
```

关于 lambda 演算的相关内容推荐阅读 [Lambda演算系列翻译](https://cgnail.github.io/tags/#lambda%E6%BC%94%E7%AE%97)


### 标识符 {#标识符}

lambda演算在求值时不能引用任何没有被绑定的标识符, 如果一个标识符是闭合lambda表达式的参数, 那么我们称这个标识符是被绑定的; 如果标识符在上下文中都没有被绑定, 那么称它为 `自由变量`

```haskell
(\x -> plus x y) -- x 是绑定的, plus 和 y 是自由变量
(\y -> (\x -> plus x y))
-- 对于内层lambda来说y是自由变量, 对于整体来说x/y都是绑定的, plus是自由变量
```

lambda演算只有所有变量都是绑定的才完全合法, 但是我们脱离上下文描述一个复杂表达式时, 自由变量是允许存在的, 我们一般将自由变量写作 `(free e)`


### 运算法则 {#运算法则}


#### Alpha 替换 {#alpha-替换}

Alpha是一个重命名操作, 即变量的名称是不重要的, 我们可以修改lambda演算中的参数名称, 只要我们同时修改函数体内所有对它的自由引用即可, 但是变量名不能有冲突。

例如, 我们将上面一个表达式进行Alpha替换, 将x变为y, 写作 `alpha[x/y]`, 则得到下面的表达式

> (\x -> if x == 0 then 1 else x ^ 2)
>
> (\y -> if y == 0 then 1 else y ^ 2)


#### Beta 归约 {#beta-归约}

Beta可以让lambda演算执行任何可以由机器来完成的计算, 如果你有一个函数应用, 你可以对这个函数体中和对应函数标识符相关部分做替换, 替换方法是把标识符用参数值替换。

同理, 我们对上面一个表达式做Beta归约, 用标识符q替换所有的引用参数y, 则得到下面的表达式

> (\y -> (\x -> x + y)) q
>
> (\x -> x + q)

Beta规则的形式化写法为:

> (\x -> B e = B[x := e] if (free e) subset (free B[x := e]))

我们只有在不引起标识符冲突的情况下, 才可以进行Beta归约, 如果冲突我们首先需要 Alpha 替换解决冲突。

