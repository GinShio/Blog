<!DOCTYPE html>
<html lang="">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Haskell入门 (1) – 类型与表达式 - iris</title><meta name="Description" content="GinShio | Haskell函数式编程入门 (第二章读书笔记)"><meta property="og:title" content="Haskell入门 (1) – 类型与表达式" />
<meta property="og:description" content="GinShio | Haskell函数式编程入门 (第二章读书笔记)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.ginshio.org/2020/haskell_type_and_expr/" />
<meta property="og:image" content="https://blog.ginshio.org/logo.png"/>
<meta property="article:published_time" content="2020-11-20T17:03:00+08:00" />
<meta property="article:modified_time" content="2020-11-22T17:19:27+08:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://blog.ginshio.org/logo.png"/>

<meta name="twitter:title" content="Haskell入门 (1) – 类型与表达式"/>
<meta name="twitter:description" content="GinShio | Haskell函数式编程入门 (第二章读书笔记)"/>
<meta name="application-name" content="iris">
<meta name="apple-mobile-web-app-title" content="iris"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://blog.ginshio.org/2020/haskell_type_and_expr/" /><link rel="prev" href="https://blog.ginshio.org/2020/mail_server/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><meta name="google-site-verification" content="3DtrOvI7RNNMN-_7YHUNA58kZEgHJ5Qxh4nPZaCmLHk" /><meta name="msvalidate.01" content="62D7DBD61D766DFB9EFEBFD7930695B8" /><meta name="baidu-site-verification" content="tSdWk62L4KBQIcLW" /><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Haskell入门 (1) – 类型与表达式",
        "inLanguage": "",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/blog.ginshio.org\/2020\/haskell_type_and_expr\/"
        },"image": ["https:\/\/blog.ginshio.org\/images\/screenshot.png"],"genre": "posts","keywords": "笔记, FP, 编程语言","wordcount":  5131 ,
        "url": "https:\/\/blog.ginshio.org\/2020\/haskell_type_and_expr\/","datePublished": "2020-11-20T17:03:00+08:00","dateModified": "2020-11-22T17:19:27+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "GinShio","logo": "https:\/\/blog.ginshio.org\/logo.png"},"author": {
                "@type": "Person",
                "name": "GinShio"
            },"description": "GinShio | Haskell函数式编程入门 (第二章读书笔记)"
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('light' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'light' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="iris"><span class="header-title-pre"><i class='fas fa-terminal fa-fw'></i></span>iris</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"><i class="fa fa-archive faa-wrench"></i> 归档 </a><a class="menu-item" href="/tags/"><i class="fa fa-tag faa-wrench"></i> 标签 </a><a class="menu-item" href="/categories/"><i class="fa fa-folder-open faa-wrench"></i> 分类 </a><a class="menu-item" href="/about/"><i class="fa fa-info-circle faa-wrench"></i> 关于 </a><a class="menu-item" href="/links/"><i class="fa fa-user-friends faa-wrench"></i> 友人帐 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="iris"><span class="header-title-pre"><i class='fas fa-terminal fa-fw'></i></span>iris</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title=""><i class="fa fa-archive faa-wrench"></i>归档</a><a class="menu-item" href="/tags/" title=""><i class="fa fa-tag faa-wrench"></i>标签</a><a class="menu-item" href="/categories/" title=""><i class="fa fa-folder-open faa-wrench"></i>分类</a><a class="menu-item" href="/about/" title=""><i class="fa fa-info-circle faa-wrench"></i>关于</a><a class="menu-item" href="/links/" title=""><i class="fa fa-user-friends faa-wrench"></i>友人帐</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content always-active" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Haskell入门 (1) – 类型与表达式</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://blog.ginshio.org/" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>GinShio</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/haskell/"><i class="far fa-folder fa-fw"></i>Haskell</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2020-11-20">2020-11-20</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 5131 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 11 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#基础类型">基础类型</a>
      <ul>
        <li><a href="#布尔类型--bool">布尔类型 (Bool)</a></li>
        <li><a href="#字符类型--char">字符类型 (Char)</a></li>
        <li><a href="#整型">整型</a></li>
        <li><a href="#浮点数与有理数">浮点数与有理数</a></li>
        <li><a href="#列表--list">列表 (List)</a></li>
        <li><a href="#元组--tuple">元组 (Tuple)</a></li>
        <li><a href="#类型别名">类型别名</a></li>
        <li><a href="#函数类型">函数类型</a></li>
      </ul>
    </li>
    <li><a href="#类型类">类型类</a>
      <ul>
        <li><a href="#相等类型类--eq">相等类型类 (Eq)</a></li>
        <li><a href="#有序类型类--ord">有序类型类 (Ord)</a></li>
        <li><a href="#枚举类型类--enum">枚举类型类 (Enum)</a></li>
        <li><a href="#有界类型类--bounded">有界类型类 (Bounded)</a></li>
        <li><a href="#可显示类型类--show">可显示类型类 (Show)</a></li>
        <li><a href="#数字类型类--num">数字类型类 (Num)</a></li>
      </ul>
    </li>
    <li><a href="#表达式">表达式</a>
      <ul>
        <li><a href="#条件表达式">条件表达式</a></li>
        <li><a href="#守卫表达式--guarded-expression">守卫表达式 (guarded expression)</a></li>
        <li><a href="#模式匹配--pattern-match">模式匹配 (pattern match)</a></li>
        <li><a href="#自定义运算符">自定义运算符</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><p>类型系统的三个优点:</p>
<ol>
<li><strong>错误检查</strong>, 类型系统是对程序的一种限定, 人是很容易犯错的, 类型检查可以辅助用户检查程序中的类型是否正确, 帮助用户检查出大部分错误</li>
<li><strong>对于程序抽象</strong>, 将一些不同的计算分成不同的种类, 在编写程序时使它们互不干扰</li>
<li><strong>文档作用</strong>, 类型签名不但可以辅助定义函数, 还可以增加代码的可读性, 作为补充文档便于软件维护</li>
</ol>
<p>我们在学习 Haskell 时, 目前所有的操作都需要在 GHCi 解析器中进行</p>
<hr>
<h2 id="基础类型">基础类型</h2>
<p>Haskell 是强类型语言, 即每一个数据或每一个函数都有非常精确、严格的类型, 在 GHCi 中可以输入 <code>:type</code> 或 <code>:t</code> 查看数据的类型, 我们现在学习以在 <code>GHCi</code> 中操作为主。</p>
<h3 id="布尔类型--bool">布尔类型 (Bool)</h3>
<p>布尔类型是只有 <strong>True</strong> 与 <strong>False</strong> 两个值的数据类型, 另外布尔类型可以进行逻辑运算, <code>&amp;&amp;</code> 表示逻辑与运算, <code>||</code> 表示逻辑或运算, <code>not</code> 表示逻辑非运算。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kt">True</span> <span class="o">||</span> <span class="kt">False</span> <span class="c1">-- True</span>
<span class="nf">not</span> <span class="kt">True</span> <span class="c1">-- False</span>
<span class="kt">:</span><span class="kr">type</span> <span class="kt">True</span> <span class="c1">-- True :: Bool</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="字符类型--char">字符类型 (Char)</h3>
<p>由单引号包裹的单字符类型, 并且字符也遵循 <code>ASCII</code> 码转义, 除了单字符外还可以用 <strong>反斜线</strong> 加 <strong>ASCII码</strong> 表示一个字符, 当然也可以使用转义字符表示ASCII表中的控制字符, 同时还支持 <strong>Unicode</strong> 字符</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="sc">&#39;A&#39;</span> <span class="c1">-- &#39;A&#39;, ascii: 65</span>
<span class="sc">&#39;</span><span class="se">\97</span><span class="sc">&#39;</span> <span class="c1">-- &#39;a&#39;, ascii: 97</span>
<span class="sc">&#39;</span><span class="se">\n</span><span class="sc">&#39;</span> <span class="c1">-- &#39;\n&#39;, LF, ascii: 10</span>
<span class="sc">&#39;ε&#39;</span> <span class="c1">-- &#39;\949&#39;, ε, unicode: 949</span>
<span class="sc">&#39;</span><span class="se">\22963</span><span class="sc">&#39;</span> <span class="c1">-- &#39;\22963&#39;, 妳, unicode: 22963</span>
<span class="kt">:</span><span class="kr">type</span> <span class="sc">&#39;</span><span class="se">\0</span><span class="sc">&#39;</span> <span class="c1">-- &#39;\0&#39; :: Char</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="整型">整型</h3>
<p>整数类型, 与其他语言相似, 原生整型也分为了有符号和无符号两种类型, 一般书写整数时使用十进制表示, 不过有时我们还需要其他进制的表示方式, Haskell还提供了八进制 (前缀 <code>0o</code>) 与十六进制 (前缀 <code>0x</code>) 的表示方式。Haskell2010 标准中并没有对二进制表示作出规定, 如果要使用二进制 (前缀 <code>0b</code>) 表示, 需要使用编译器的语法扩展 <strong>BinaryLiterals</strong> (GHC v7.10 or later)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="mh">0x3F3F3F</span> <span class="c1">-- 十六进制整数, 4144959</span>
<span class="mi">465</span> <span class="c1">-- 十进制整数</span>
<span class="mo">0o1234567</span> <span class="c1">-- 八进制整数, 342391</span>
<span class="kt">:</span><span class="n">set</span> <span class="o">-</span><span class="kt">XBinaryLiterals</span> <span class="c1">-- 开启GHC语法扩展以支持整数二进制表示</span>
<span class="mi">0</span><span class="n">b01101001</span> <span class="c1">-- 二进制整数, 105</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p><strong>有符号整型</strong> (Int):
整数类型, 大小与操作系统和GHC的位数有关, 32位的话范围是 \(-2^{31}~2^{31}-1\), 64位的话范围是 \(-2^{63}~2^{63}-1\), 除了默认位数的有符号整型之外, Haskell 还提供了指定位数的有符号整型 <code>Int8</code> 、 <code>Int16</code> 、 <code>Int32</code> 和 <code>Int64</code>, 指定位数的有符号整型需要引入模块 <strong>Data.Int</strong></p>
</li>
<li>
<p><strong>无符号整型</strong> (Word):
整数类型, 与有符号整型相似, 区别在于它表示的是无符号数, 64位GHC的Word范围为 \(0~2^{64}-1\), 除了默认位数的无符号整型之外, Haskell 还提供了指定位数的无符号整型 <code>Word8</code> 、 <code>Word16</code> 、 <code>Word32</code> 和 <code>Word64</code> , 指定位数的无符号整型需要引入模块 <strong>Data.Word</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="o">-</span><span class="mi">1</span> <span class="ow">::</span> <span class="kt">Word</span> <span class="c1">-- Word 下溢出, 18446744073709551615</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>任意精度整数</strong> (Integer):
整数类型, 可以表示任意大小的整数, 不再受限于操作系统或GHC的位数限制, 可表示的范围受到内容限制, 其性能无法与原生整型相比</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="mi">2</span><span class="o">^</span><span class="mi">128</span> <span class="c1">-- 340282366920938463463374607431768211456</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="浮点数与有理数">浮点数与有理数</h3>
<ul>
<li>
<p><strong>浮点数</strong> 是原生类型, 分为 <code>单精度</code> (Float) 与 <code>双精度</code> (Double) 浮点数, 浮点数遵循 <strong>IEEE754</strong> 标准, 相比其他语言中的浮点数没有什么区别</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">pi</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="c1">-- 3.1415927</span>
<span class="nf">pi</span> <span class="ow">::</span> <span class="kt">Double</span> <span class="c1">-- 3.141592653589793</span>
</code></pre></td></tr></table>
</div>
</div><p>浮点数在处理的过程中会有一些非常特殊的值, <strong>非数</strong> (NaN) 和 <strong>无穷大</strong> (Infinity), 它们的产生都与除数为0有关, NaN是由于被除数与除数都为零导致的, 在标准中, NaN 不与任何值比较相等, 包括它本身; 而infinity的出现是由于被除数不为零, 不过遗憾的是我们并不能直接使用这两个值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="mi">100</span> <span class="o">/</span> <span class="mi">0</span> <span class="c1">-- Infinity</span>
<span class="mf">0.0</span> <span class="o">/</span> <span class="mf">0.0</span> <span class="c1">-- NaN</span>
<span class="o">-</span><span class="mi">5</span> <span class="o">/</span> <span class="mf">0.0</span> <span class="c1">-- -Infinity</span>
<span class="p">(</span><span class="mi">0</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/=</span> <span class="p">(</span><span class="mf">0.0</span> <span class="o">/</span> <span class="mf">0.0</span><span class="p">)</span> <span class="c1">-- True</span>
<span class="p">(</span><span class="mf">5.0</span> <span class="o">/</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">/=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">-- False</span>
<span class="p">(</span><span class="mi">0</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">-- False</span>
<span class="p">(</span><span class="mf">5.0</span> <span class="o">/</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">-- True</span>
<span class="p">(</span><span class="mi">5</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">0</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">-- False</span>
<span class="p">(</span><span class="mi">5</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">0</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">-- False</span>
</code></pre></td></tr></table>
</div>
</div><p>我们可以安装 <strong>Numeric.IEEE</strong> 模块, 使用基于 RealFloat 类型类定义的IEEE类型类, 它包含了我们常用的处理 IEEE 类型的方法以及类型</p>
</li>
<li>
<p><strong>有理数</strong> (Rational) 是用两个任意精度的整数来表示小数的类型, 如果了解浮点数的规范可以明白 Rational 可以提供任意精度的有理数, 在输出中 <code>%</code> 代表分数线, 分数线前的为分子</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="mf">4.133332</span> <span class="ow">::</span> <span class="kt">Rational</span> <span class="c1">-- 1033333 % 250000</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h3 id="列表--list">列表 (List)</h3>
<p>列表是同一类型的多个元素的集合, 类似于其他语言中的数组, 不过列表可以动态的修改数据, 而数组是定长的, 我们可以使用 <code>!!</code> 运算符通过下标取得列表中的元素, Haskell 中与其他语言一样下标从零开始</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="c1">-- 一个整数列表</span>
<span class="c1">-- [1,2,&#39;C&#39;,3.15] -- 错误的列表, 包含了不同类型的数据</span>
<span class="kt">:</span><span class="n">t</span> <span class="p">[</span><span class="mf">3.14</span><span class="ow">::</span><span class="kt">Float</span><span class="p">,</span><span class="mf">1.73</span><span class="p">]</span> <span class="c1">-- [Float]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="o">!!</span> <span class="mi">2</span> <span class="c1">-- 3</span>
</code></pre></td></tr></table>
</div>
</div><p>你可以使用 <code>:</code> (cons) 操作符将新数据附加到列表上, 从而创建一个新列表, 不过它只能 <strong>push_front</strong>, 我们常常使用方括号创建列表, 就像是cons空列表的语法糖。除了cons, 你肯定会对repeat感兴趣, 它允许你生成一个无限长的只有给定值的列表</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="mi">0</span><span class="kt">:</span><span class="mi">1</span><span class="kt">:</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="c1">-- [-1,0,1,2,3]</span>
<span class="c1">-- [5,6,7]:8 -- 错误</span>
<span class="mi">9</span><span class="kt">:</span><span class="mi">8</span><span class="kt">:</span><span class="mi">7</span><span class="kt">:</span><span class="mi">6</span><span class="kt">:</span><span class="mi">5</span><span class="kt">:[]</span> <span class="c1">-- 创建一个新列表 [9,8,7,6,5]</span>
<span class="c1">-- 4:3:2:1 -- 错误</span>
<span class="nf">repeat</span> <span class="mi">5</span> <span class="c1">-- 生成一个只有5的无限长列表</span>
</code></pre></td></tr></table>
</div>
</div><p>好消息, 列表是可以嵌套的, 当然嵌套的条件是元素类型相同</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="p">[[</span><span class="mf">3.142</span><span class="ow">::</span><span class="kt">Float</span><span class="p">,</span><span class="mf">2.718</span><span class="p">],[</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">]]</span> <span class="c1">-- 嵌套的单精度浮点数列表</span>
<span class="kt">:</span><span class="n">t</span> <span class="p">[[</span><span class="mf">3.142</span><span class="ow">::</span><span class="kt">Float</span><span class="p">,</span><span class="mf">2.718</span><span class="p">],[</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">]]</span> <span class="c1">-- [[Float]]</span>
</code></pre></td></tr></table>
</div>
</div><p>字符串类型是使用列表实现的, 即 [Char], 和其他语言一样, 也可以使用 <code>&quot;String&quot;</code> 来表示字符串</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="p">[</span><span class="sc">&#39;H&#39;</span><span class="p">,</span><span class="sc">&#39;e&#39;</span><span class="p">,</span><span class="sc">&#39;l&#39;</span><span class="p">,</span><span class="sc">&#39;l&#39;</span><span class="p">,</span><span class="sc">&#39;o&#39;</span><span class="p">]</span> <span class="c1">-- &#34;Hello&#34;</span>
<span class="kt">:</span><span class="n">t</span> <span class="s">&#34;World&#34;</span> <span class="c1">-- [Char]</span>
</code></pre></td></tr></table>
</div>
</div><p>列表的操作还有还多, 如果你学过Python你一定对列表推导式这个东西很熟悉, 它允许你使用一个表达式生成新的列表</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span> <span class="c1">-- [2,6,10]</span>
<span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">]</span> <span class="c1">-- [12,18,20,30]</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="元组--tuple">元组 (Tuple)</h3>
<p>元组是多个元素的集合, 每个元素称之为该元组的 <strong>元件</strong> (component), 对元素的类型不要求必须一致, 但是元组一旦确定就不能在改变其大小与元素的类型。我们将长度为2的元组称为 <strong>pair</strong>, 长度为3的元组称为 <strong>triple</strong>, 长度为n的则称其为 <code>n-tuple</code>, 如果你使用GHC请牢记, 元组最多拥有62个元素。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="p">(</span><span class="mi">4</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">pi</span> <span class="ow">::</span> <span class="kt">Float</span><span class="p">)</span> <span class="c1">-- (4,3.1415927)</span>
<span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="mi">4</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">pi</span> <span class="ow">::</span> <span class="kt">Float</span><span class="p">)</span> <span class="c1">-- (Int, Float)</span>
</code></pre></td></tr></table>
</div>
</div><p>如果想将元件从pair中取出, 可以使用 <code>fst</code> 和 <code>snd</code> 这两个函数分别取出pair的第一个元素和第二个元素。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">fst</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#34;str&#34;</span><span class="p">)</span> <span class="c1">-- 1</span>
<span class="nf">snd</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#34;str&#34;</span><span class="p">)</span> <span class="c1">-- &#34;str&#34;</span>
<span class="c1">-- fst (1, &#34;str&#34;, 3.14) -- 错误</span>
</code></pre></td></tr></table>
</div>
</div><p>当然, 元组与列表很相似, 它也是可以嵌套的, 并且你会感到比列表更自由。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="p">([</span><span class="mi">0</span><span class="ow">::</span><span class="kt">Int</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">,</span> <span class="s">&#34;World&#34;</span><span class="p">),</span> <span class="sc">&#39;C&#39;</span><span class="p">)</span> <span class="c1">-- ([0,1,2],(&#34;Hello&#34;,&#34;World&#34;),&#39;C&#39;)</span>
<span class="kt">:</span><span class="n">t</span> <span class="p">([</span><span class="mi">0</span><span class="ow">::</span><span class="kt">Int</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">,</span> <span class="s">&#34;World&#34;</span><span class="p">),</span> <span class="sc">&#39;C&#39;</span><span class="p">)</span> <span class="c1">-- ([Int], ([Char], [Char]), Char)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="类型别名">类型别名</h3>
<p>以上基本类型介绍完毕, 有时我们写一些程序时需要使用一些固定形式的类型, 就比如一个RGB图片的像素我们一般定义为 <code>(Word8,Word8,Word8)</code>, 这样写很不方便, Haskell 为我们提供了定义类型别名的方法, 允许我们将复杂的类型替换为其他名字, 在定义时类型的名字一定要以大写字母开头。字符串类型就是字符列表的别名。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">RGB</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Word8</span><span class="p">,</span><span class="kt">Word8</span><span class="p">,</span><span class="kt">Word8</span><span class="p">)</span>
<span class="kr">type</span> <span class="kt">Picture</span> <span class="ow">=</span> <span class="p">[[</span><span class="kt">RGB</span><span class="p">]]</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="函数类型">函数类型</h3>
<p>函数可以理解为从参数到结果的映射, 类似的 <code>T1 -&gt; T2</code>, 参数和结果可以是任意类型的数据, 如果 T1 或 T2 为函数的话, 我们称 <code>T1 -&gt; T2</code> 为 <strong>高阶函数</strong>, 不过无论什么类型它们都符合函数的定义。我们为函数传递多个参数时, 以元组的形式向函数输入。如下我们定义一个add函数, 我们可以使用 <code>let</code> 也可以不使用let定义一个函数, 第一部分为函数名, 接下来是这个函数接受的参数, 这个函数接受一个元组, 等号之后是这个函数的函数体, 它返回 Int 类型。这个add函数必须一次性全部传入参数才可以, 这种函数被称为 <strong>非柯里化函数</strong> (uncurried function)。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">add</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="c1">-- 函数定义</span>
<span class="kt">:</span><span class="n">t</span> <span class="n">add</span> <span class="c1">-- 函数类型: (Int, Int) -&gt; Int</span>
<span class="nf">add</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">-- 函数调用, 3</span>
</code></pre></td></tr></table>
</div>
</div><p>当函数有多个参数时, 参数可以一个一个一次输入, 参数不足时将返回一个函数作为结果, 这样的函数就是 <strong>柯里化函数</strong> (curried function)。这里我们定义一个柯里化的add函数, 当传递一个参数时, 它将返回 <code>Int -&gt; Int</code> 类型的函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">add&#39;</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="ow">::</span><span class="kt">Int</span> <span class="c1">-- 柯里化函数定义</span>
<span class="kt">:</span><span class="n">t</span> <span class="n">add&#39;</span> <span class="c1">-- 函数类型: Int -&gt; Int -&gt; Int</span>
<span class="nf">add5</span> <span class="ow">=</span> <span class="n">add&#39;</span> <span class="mi">5</span>
<span class="kt">:</span><span class="n">t</span> <span class="n">add5</span> <span class="c1">-- Int -&gt; Int</span>
<span class="nf">add&#39;</span> <span class="mi">1</span> <span class="mi">3</span> <span class="c1">-- 4</span>
<span class="nf">add5</span> <span class="mi">7</span> <span class="c1">-- 12</span>
</code></pre></td></tr></table>
</div>
</div><p>当然我们可以将一个非柯里化函数转换为柯里化函数, 或者反过来转换, 都是可以的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">curried_add</span> <span class="ow">=</span> <span class="n">curry</span> <span class="n">add</span> <span class="c1">-- 将 add 柯里化</span>
<span class="kt">:</span><span class="n">t</span> <span class="n">curried_add</span> <span class="c1">-- Int -&gt; Int -&gt; Int</span>
<span class="kt">:</span><span class="n">t</span> <span class="n">curry</span> <span class="c1">-- ((a, b) -&gt; c) -&gt; a -&gt; b -&gt; c</span>
<span class="nf">curried_add</span> <span class="mi">1</span> <span class="mi">2</span> <span class="c1">-- 3</span>
<span class="nf">uncurried_add&#39;</span> <span class="ow">=</span> <span class="n">uncurry</span> <span class="n">add&#39;</span> <span class="c1">-- 将 add&#39; 非柯里化</span>
<span class="kt">:</span><span class="n">t</span> <span class="n">uncurried_add&#39;</span> <span class="c1">-- (Int, Int) -&gt; Int</span>
<span class="kt">:</span><span class="n">t</span> <span class="n">uncurry</span> <span class="c1">-- (a -&gt; b -&gt; c) -&gt; (a, b) -&gt; c</span>
<span class="nf">uncurried_add&#39;</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="c1">-- 5</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p><strong>多态函数</strong>:
很多函数的参数不一定要传入具体的类型, 比如上面学习元组时使用的 fst 函数, 不管pair是什么类型, fst总能正确返回第一个元件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">fst</span> <span class="p">(</span><span class="mi">1</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">pi</span> <span class="ow">::</span> <span class="kt">Float</span><span class="p">)</span> <span class="c1">-- 1</span>
<span class="nf">fst</span> <span class="p">(</span><span class="n">pi</span> <span class="ow">::</span> <span class="kt">Float</span><span class="p">,</span> <span class="mi">1</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">)</span> <span class="c1">-- 3.1415927</span>
<span class="kt">:</span><span class="n">t</span> <span class="n">fst</span> <span class="c1">-- (a, b) -&gt; a</span>
</code></pre></td></tr></table>
</div>
</div><p>一个函数的某个参数可以是任何类型的值, 那么这个函数是一个多态函数, 我们使用小写字母开头的单词表示任意类型, 这些标识符被成为 <code>类型变量</code>, 类型变量是多态的, 它可以被替换为任意类型 (具体类型或多态类型), 我们之前学过的 curry 和 uncrry 也是多态函数。</p>
</li>
<li>
<p><strong>重载类型函数</strong>:
我们在GHCi中查看5的类型会发现它返回的并不是Int或Word, 返回的是 <code>Num a =&gt; a</code>, 这里的这个 Num 是一个类型类, 5可以是任意的a类型 (当然a类型被限定在了Num类型类中), 而像5这种有着多种类型的字面量被称为重载字面量。Haskell中重载类型函数也被成为 <strong>受限的多态类型函数</strong>, 这个说法很贴切, 我们把函数需要的参数的限制在了类型类之中, 不是这个类型类的参数是无法作为参数传递给这个函数的。在声明时, 需要将类型类限定放在类型签名 <strong>=&gt;</strong> 的左侧, 说明哪些类型变量是被类型类限定的, <strong>=&gt;</strong> 右边则是对其类型的声明。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kt">:</span><span class="n">t</span> <span class="mi">5</span> <span class="c1">-- Num p =&gt; p</span>
<span class="kt">:</span><span class="n">t</span> <span class="sc">&#39;C&#39;</span> <span class="c1">-- Char</span>
<span class="nf">add</span> <span class="ow">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">;</span> <span class="n">add</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="c1">-- 重载类型的curried add</span>
<span class="kt">:</span><span class="n">t</span> <span class="n">add</span> <span class="c1">-- Num a =&gt; a -&gt; a -&gt; a, 接受两个Num类型类的参数, 并返回一个Num类型类的变量</span>
<span class="nf">add</span> <span class="mi">1</span> <span class="mi">2</span> <span class="c1">-- 3</span>
<span class="nf">add</span> <span class="mf">3.0</span> <span class="mf">4.0</span> <span class="c1">-- 7.0</span>
<span class="nf">add</span> <span class="mi">32</span> <span class="mf">64.0</span> <span class="c1">-- 96.0</span>
</code></pre></td></tr></table>
</div>
</div><p>很多语言可以自由地根据参数的数量进行函数重载, 但是Haskell中函数或运算符的定义是 <strong>唯一的</strong>, 重载的话需要借助类型类, 并非根据参数数量进行重载。</p>
</li>
</ul>
<hr>
<h2 id="类型类">类型类</h2>
<p>Haskell将类型分成了类型类, 归为一类的类型拥有着相同的属性, 不同类型所归的类称为类型类。我们可以在GHCi中使用 <code>:i</code> 查看类型类的详情, 不止可以看到类型类是在哪里定义的、如何定义的、有哪些类型实例。在其他语言中, 类型类的概念与接口相似。</p>
<h3 id="相等类型类--eq">相等类型类 (Eq)</h3>
<p>允许类型比较相等的类型类。Eq包含了两个函数, 比较相等 (<strong>==</strong>) 和 比较不等 (<strong>/=</strong>)。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="o">==</span><span class="p">)</span> <span class="c1">-- Eq a =&gt; a -&gt; a -&gt; Bool</span>
<span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="o">/=</span><span class="p">)</span> <span class="c1">-- Eq a =&gt; a -&gt; a -&gt; Bool</span>
<span class="mi">5</span> <span class="o">==</span> <span class="mi">4</span> <span class="c1">-- False</span>
<span class="mi">4</span> <span class="o">/=</span> <span class="mf">4.0</span> <span class="c1">-- False</span>
<span class="mf">3.14</span> <span class="o">/=</span> <span class="mi">3</span> <span class="c1">-- True</span>
<span class="c1">-- &#39;A&#39; == 65 -- 错误, 不能比较Num与Char</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="有序类型类--ord">有序类型类 (Ord)</h3>
<p>允许类型比较大小的类型类, Haskell 规定一个有序类型一定是一个比较相等的类型, 即Ord是基于Eq的。Ord包含了 比较大于 (<strong>&gt;</strong>)、比较小于 (<strong>&lt;</strong>)、比较大于等于 (<strong>&gt;=</strong>) 以及比较小于等于 (<strong>&lt;=</strong>)。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="o">&lt;</span><span class="p">)</span> <span class="c1">-- Ord a =&gt; a -&gt; a -&gt; Bool</span>
<span class="s">&#34;Hello&#34;</span> <span class="o">&lt;</span> <span class="s">&#34;World&#34;</span> <span class="c1">-- True</span>
<span class="mi">3</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">pi</span> <span class="ow">::</span> <span class="kt">Float</span><span class="p">)</span> <span class="c1">-- True</span>
<span class="nf">gt3</span> <span class="ow">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;</span><span class="p">)</span> <span class="c1">-- 定义一个判断是否大于3的函数</span>
<span class="kt">:</span><span class="n">t</span> <span class="n">gt3</span> <span class="c1">-- (Ord a, Num a) =&gt; a -&gt; Bool</span>
<span class="nf">gt3</span> <span class="p">(</span><span class="n">pi</span> <span class="ow">::</span> <span class="kt">Float</span><span class="p">)</span> <span class="c1">-- True</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="枚举类型类--enum">枚举类型类 (Enum)</h3>
<p>一些类型允许我们可以按一定顺序枚举。给定一个枚举类型的非最后一个元素, 那么我们可以使用 <code>succ</code> 获取它的后继, 同样的我们对非首个元素可以使用 <code>pred</code> 来获取它的前驱。我们也可以使用语法 <code>[a..d]</code> 来生成一个列表有序列表 (浮点类型由于特殊性生成的列表间隔默认为1.0), 我们也可以让Haskell为我们推导生成列表时的间隔 <code>[a,b..d]</code> 。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kt">:</span><span class="n">t</span> <span class="n">succ</span> <span class="c1">-- Enum a =&gt; a -&gt; a</span>
<span class="nf">succ</span> <span class="mi">6</span> <span class="c1">-- 7</span>
<span class="nf">pred</span> <span class="sc">&#39;X&#39;</span> <span class="c1">-- &#39;W&#39;</span>
<span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;z&#39;</span><span class="p">]</span> <span class="c1">-- &#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`a&#34;</span>
<span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">12</span><span class="p">]</span> <span class="c1">-- [1,2,3,4,5,6,7,8,9,10,11,12]</span>
<span class="p">[(</span><span class="n">pi</span><span class="ow">::</span><span class="kt">Float</span><span class="p">)</span><span class="o">..</span><span class="mf">5.5</span><span class="p">]</span> <span class="c1">-- [3.1415927,4.141593,5.141593]</span>
<span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="ow">::</span><span class="kt">Word</span><span class="p">)</span><span class="o">..</span><span class="mi">255</span><span class="p">]</span> <span class="c1">-- [], 会报一个警告</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="o">..</span><span class="mi">36</span><span class="p">]</span> <span class="c1">-- [1,5,9,13,17,21,25,29,33], 自动推导间隔</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="有界类型类--bounded">有界类型类 (Bounded)</h3>
<p>可以枚举的数据往往是有界的, 它们需要指出类型的最大值与最小值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kt">:</span><span class="n">m</span> <span class="o">+</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Int</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Word</span>
<span class="nf">maxBound</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="c1">-- True</span>
<span class="nf">minBound</span> <span class="ow">::</span> <span class="kt">Int8</span> <span class="c1">-- -128</span>
<span class="c1">-- minBound :: Integer -- 错误, Integer 不是有界类型</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="可显示类型类--show">可显示类型类 (Show)</h3>
<p>比如, 我们在GHCi中可以输出一些数字、字符等等, 正是因为它们都是Show类型类的成员, 这类似于C++中一个类实现了重载 <code>ostream&amp; operator&lt;&lt;(ostream&amp; os, T t);</code> 或者Java中 <code>toString</code> 方法, 不过函数可不是Show类型类的成员。</p>
<h3 id="数字类型类--num">数字类型类 (Num)</h3>
<p>Num是最复杂的类型类之一, 下图展示了Num与其他类型类之间的关系, 可以看到这是相当复杂的一个类型类, 当然也足够强大。
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="../static/blog/Haskell/num_typeclass.png"
        data-srcset="../static/blog/Haskell/num_typeclass.png, ../static/blog/Haskell/num_typeclass.png 1.5x, ../static/blog/Haskell/num_typeclass.png 2x"
        data-sizes="auto"
        alt="../static/blog/Haskell/num_typeclass.png"
        title="../static/blog/Haskell/num_typeclass.png" /></p>
<hr>
<h2 id="表达式">表达式</h2>
<p>表达式是又运算符与运算数构成的, Haskell 中所有的运算符都是基于函数定义的。例如 <code>(+)</code> 的类型是 <strong>Num a =&gt; a -&gt; a -&gt; a</strong>, 运算符是规定了可以放在参数中间或末尾的函数, 并且使用的特殊的符号进行表示。在GHCi中我们使用 <code>(+) 5 6</code> 与 <code>5 + 6</code> 是相同的, 或者 <code>div 5 2</code> 与 <code>5 `div` 2</code> 。</p>
<p>运算符有三种属性, <strong>优先级</strong> (precedence)、 <strong>结合性</strong> (associativity) 与 <strong>位置</strong> (fixity), 优先级分为了0~9共10级, 而结合性分为左结合、右结合、无结合, 函数拥有 <strong>最高优先级</strong> 且是左结合的。
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/blog/Haskell/images/operator_precedence.svg"
        data-srcset="/blog/Haskell/images/operator_precedence.svg, /blog/Haskell/images/operator_precedence.svg 1.5x, /blog/Haskell/images/operator_precedence.svg 2x"
        data-sizes="auto"
        alt="/blog/Haskell/images/operator_precedence.svg"
        title="/blog/Haskell/images/operator_precedence.svg" /></p>
<h3 id="条件表达式">条件表达式</h3>
<p><code>if-then-else</code> 结构是最简单的条件表达式, 并且是可以嵌套的, 不过必须有else表达式返回不成立的结果</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">gt2</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span> <span class="kr">then</span> <span class="kt">True</span> <span class="kr">else</span> <span class="kr">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="kr">then</span> <span class="kt">False</span> <span class="kr">else</span> <span class="kt">True</span>
</code></pre></td></tr></table>
</div>
</div><p><code>case-of</code> 结构和其他编程语言中的 <code>switch-case</code> 类似, 不过其他语言中的 default 关键字被替换为了 <code>_</code>, 当匹配到一个条件后可以自动退出结构而不再需要 break</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">week</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">n</span> <span class="kr">of</span> <span class="mi">1</span> <span class="ow">-&gt;</span> <span class="s">&#34;Mon&#34;</span><span class="p">;</span> <span class="mi">2</span> <span class="ow">-&gt;</span> <span class="s">&#34;Tue&#34;</span><span class="p">;</span> <span class="mi">3</span> <span class="ow">-&gt;</span> <span class="s">&#34;Wed&#34;</span><span class="p">;</span> <span class="mi">4</span> <span class="ow">-&gt;</span> <span class="s">&#34;Thu&#34;</span><span class="p">;</span> <span class="mi">5</span> <span class="ow">-&gt;</span> <span class="s">&#34;Fri&#34;</span><span class="p">;</span> <span class="mi">6</span> <span class="ow">-&gt;</span> <span class="s">&#34;Sat&#34;</span><span class="p">;</span> <span class="mi">7</span> <span class="ow">-&gt;</span> <span class="s">&#34;Sun&#34;</span><span class="p">;</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="ne">error</span> <span class="s">&#34;invalid&#34;</span>
<span class="kt">:</span><span class="n">t</span> <span class="n">week</span> <span class="c1">-- (Eq a, Num a) =&gt; a -&gt; [Char]</span>
<span class="nf">week</span> <span class="mi">5</span> <span class="c1">-- &#34;Fri&#34;</span>
<span class="nf">week</span> <span class="mi">8</span> <span class="c1">-- Exception: invalid</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="守卫表达式--guarded-expression">守卫表达式 (guarded expression)</h3>
<p>使用 <code>|</code> 将函数的参数按特定的条件分开, 如果不能满足条件则不会让不符合条件的表达式运算, 不过不同条件的守卫表达式的 | 需要对齐。守卫后跟的是一个布尔类型, 当有多个条件满足时, Haskell 只会匹配第一个, 默认的守卫使用 <strong>otherwise</strong> 表示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">my_abs</span> <span class="n">n</span> <span class="o">|</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">=</span> <span class="n">n</span> <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="o">-</span><span class="n">n</span>
<span class="kt">:</span><span class="n">t</span> <span class="n">my_abs</span> <span class="c1">-- (Ord p, Num p) =&gt; p -&gt; p</span>
<span class="nf">my_abs</span> <span class="mi">5</span>  <span class="c1">-- 5</span>
<span class="nf">my_abs</span> <span class="p">(</span><span class="o">-</span><span class="mf">3.14</span><span class="p">)</span> <span class="c1">-- 3.14</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="模式匹配--pattern-match">模式匹配 (pattern match)</h3>
<p>模式指一个类型的值或定义成的形式, 模式匹配与 <code>case-of</code> 结构类似, 每个类型的数据都可以看作该类型的一个具体形式, 如果有多个复合的匹配, 则只有第一个匹配被执行。我们需要将所有的模式都定义好, 否则的话在函数调用时将会出现 <code>exception of non-exhaustive patterns</code> 的错误</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">my_head</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">&#34;empty&#34;</span><span class="p">;</span> <span class="n">my_head</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span>
<span class="kt">:</span><span class="n">t</span> <span class="n">my_head</span> <span class="c1">-- [p] -&gt; p</span>
<span class="nf">my_head</span> <span class="s">&#34;String&#34;</span> <span class="c1">-- &#39;S&#39;</span>
<span class="nf">my_head</span> <span class="p">(</span><span class="mi">1</span><span class="kt">:</span><span class="mi">2</span><span class="kt">:</span><span class="mi">3</span><span class="kt">:[]</span><span class="p">)</span> <span class="c1">-- 1</span>
<span class="nf">my_head</span> <span class="kt">[]</span> <span class="c1">-- Exception: empty</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="自定义运算符">自定义运算符</h3>
<p>Haskell 虽然不能像C++那样重载运算符, 但是可以定义自己的运算符, 不过需要声明运算符的结合性与优先级, 我们使用关键字定义新的运算符: <code>infix</code> (无结合)、 <code>infixl</code> (左结合)、 <code>infixr</code> (右结合)。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">infixr</span> <span class="mi">5</span> <span class="o">&lt;-&gt;</span><span class="p">,</span> <span class="o">&lt;+&gt;</span><span class="p">;</span> <span class="p">(</span><span class="o">&lt;-&gt;</span><span class="p">)</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">;</span> <span class="p">(</span><span class="o">&lt;+&gt;</span><span class="p">)</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="o">&lt;-&gt;</span><span class="p">)</span> <span class="c1">-- Num a =&gt; a -&gt; a -&gt; a</span>
<span class="mi">10</span> <span class="o">&lt;-&gt;</span> <span class="mi">5</span> <span class="o">&lt;+&gt;</span> <span class="mi">3</span> <span class="c1">-- 2</span>
<span class="kr">infixr</span> <span class="mi">4</span> <span class="p">`</span><span class="n">foo</span><span class="p">`;</span> <span class="n">foo</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="kt">:</span><span class="n">t</span> <span class="n">foo</span> <span class="c1">-- Num a =&gt; a -&gt; a -&gt; a</span>
<span class="mi">4</span> <span class="p">`</span><span class="n">foo</span><span class="p">`</span> <span class="mi">6</span> <span class="c1">-- 10</span>
<span class="nf">foo</span> <span class="mi">5</span> <span class="mi">5</span> <span class="c1">-- 10</span>
</code></pre></td></tr></table>
</div>
</div></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2020-11-22</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/2020/haskell_type_and_expr/index.md" target="_blank">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://blog.ginshio.org/2020/haskell_type_and_expr/" data-title="Haskell入门 (1) – 类型与表达式" data-hashtags="笔记,FP,编程语言"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://blog.ginshio.org/2020/haskell_type_and_expr/" data-hashtag="笔记"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Linkedin" data-sharer="linkedin" data-url="https://blog.ginshio.org/2020/haskell_type_and_expr/"><i class="fab fa-linkedin fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Hacker News" data-sharer="hackernews" data-url="https://blog.ginshio.org/2020/haskell_type_and_expr/" data-title="Haskell入门 (1) – 类型与表达式"><i class="fab fa-hacker-news fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://blog.ginshio.org/2020/haskell_type_and_expr/" data-title="Haskell入门 (1) – 类型与表达式"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/line.svg"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://blog.ginshio.org/2020/haskell_type_and_expr/" data-title="Haskell入门 (1) – 类型与表达式"><i class="fab fa-weibo fa-fw"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a>,&nbsp;<a href="/tags/fp/">FP</a>,&nbsp;<a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/2020/mail_server/" class="prev" rel="prev" title="搭建邮箱服务器"><i class="fas fa-angle-left fa-fw"></i>搭建邮箱服务器</a></div>
</div>
<div id="comments"><div id="gitalk" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://github.com/gitalk/gitalk"></a>Gitalk</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.74.3">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2020</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://blog.ginshio.org/" target="_blank">GinShio</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lunr@2.3.8/lunr.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.stemmer.support.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.zh.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":12},"comment":{"gitalk":{"admin":["GinShio"],"clientID":"1ede37779b82f8d8a39e","clientSecret":"4dc775e507be852aa2805c6643495ed7178b7826","id":"2020-11-20T17:03:00+08:00","owner":"GinShio","repo":"Blog","title":"Haskell入门 (1) – 类型与表达式"}},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"},{"display":false,"left":"$","right":"$"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"}};</script><script type="text/javascript" src="/js/theme.min.js"></script><script type="text/javascript">
            window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());
            gtag('config', 'UA-172480612-1', { 'anonymize_ip': true });
        </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=UA-172480612-1" async></script></body>
</html>
